var documenterSearchIndex = {"docs":
[{"location":"publications/#Publications-Using-LatticeQM","page":"Publications","title":"Publications Using LatticeQM","text":"","category":"section"},{"location":"publications/","page":"Publications","title":"Publications","text":"The LatticeQM package was used in the context of the following publications and thesis:","category":"page"},{"location":"publications/","page":"Publications","title":"Publications","text":"Wolf, T. M. R.; Holst, M. F.; Sigrist, M.; Lado, J. L. (2022). Nonunitary multiorbital superconductivity from competing interactions in Dirac materials. Phys. Rev. Research 4, L012036. doi:10.1103/PhysRevResearch.4.L012036. https://link.aps.org/doi/10.1103/PhysRevResearch.4.L012036\nWolf, T. M. R.; Zilberberg, O.; Blatter, G.; Lado, J. L. (2021). Spontaneous valley spirals in magnetically encapsulated twisted bilayer graphene. Phys. Rev. Lett. 126, 056803. doi:10.1103/PhysRevLett.126.056803. https://link.aps.org/doi/10.1103/PhysRevLett.126.056803\nWolf, T. M. R. (2021). Electronic properties of twisted-layer graphene systems. PhD Thesis, ETH Zurich. doi:10.3929/ethz-b-000475934. https://doi.org/10.3929/ethz-b-000475934\nWolf, T. M. R.; Lado, J. L.; Blatter, G.; Zilberberg, O. (2019). Electrically Tunable Flat Bands and Magnetism in Twisted Bilayer Graphene. Phys. Rev. Lett. 123, 096802. doi:10.1103/PhysRevLett.123.096802. https://link.aps.org/doi/10.1103/PhysRevLett.123.096802","category":"page"},{"location":"publications/#BibTeX","page":"Publications","title":"BibTeX","text":"","category":"section"},{"location":"publications/","page":"Publications","title":"Publications","text":"@Article{Wolf2022,\n  author    = {Wolf, Tobias M. R. and Holst, Maximilian F. and Sigrist, Manfred and Lado, Jose L.},\n  journal   = {Phys. Rev. Research},\n  title     = {Nonunitary multiorbital superconductivity from competing interactions in Dirac materials},\n  year      = {2022},\n  number    = {1},\n  pages     = {L012036},\n  volume    = {4},\n  publisher = {American Physical Society},\n  doi       = {10.1103/PhysRevResearch.4.L012036},\n  url       = {https://link.aps.org/doi/10.1103/PhysRevResearch.4.L012036}\n}\n\n@Article{Wolf2021,\n  author    = {Wolf, Tobias M. R. and Zilberberg, Oded and Blatter, Gianni and Lado, Jose L.},\n  journal   = {Phys. Rev. Lett.},\n  title     = {Spontaneous valley spirals in magnetically encapsulated twisted bilayer graphene},\n  year      = {2021},\n  number    = {5},\n  pages     = {056803},\n  volume    = {126},\n  doi       = {10.1103/PhysRevLett.126.056803},\n  publisher = {American Physical Society},\n  url       = {https://link.aps.org/doi/10.1103/PhysRevLett.126.056803}\n}\n\n@PhdThesis{Wolf2021a,\n  author = {Wolf, Tobias M. R.},\n  school = {ETH Zurich},\n  title  = {Electronic properties of twisted-layer graphene systems},\n  year   = {2021},\n  doi    = {10.3929/ethz-b-000475934},\n  url    = {https://doi.org/10.3929/ethz-b-000475934},\n  note   = {\\href{https://doi.org/10.3929/ethz-b-000475934}{10.3929/ethz-b-000475934}}\n}\n\n@Article{WolfZilberberg2019PRL,\n  author       = {Wolf, Tobias M. R. and Lado, Jose L. and Blatter, Gianni and Zilberberg, Oded},\n  title        = {Electrically Tunable Flat Bands and Magnetism in Twisted Bilayer Graphrene},\n  pages        = {096802},\n  volume       = {123},\n  date         = {2019-08},\n  doi          = {10.1103/PhysRevLett.123.096802},\n  number       = {9},\n  journal      = {Phys. Rev. Lett.},\n  numpages     = {6},\n  publisher    = {American Physical Society},\n  eprint       = {1905.07651},\n  eprinttype   = {arXiv},\n  url          = {https://link.aps.org/doi/10.1103/PhysRevLett.123.096802}\n}","category":"page"},{"location":"contributing/#Contributor-Guide","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Welcome to the development side of LatticeQM. This guide outlines how to contribute code, documentation, and examples while keeping the project maintainable.","category":"page"},{"location":"contributing/#Development-setup","page":"Contributor Guide","title":"Development setup","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Fork/clone the repository and develop the package locally:\njulia\nusing Pkg\nPkg.develop(path=\"/path/to/LatticeQM\")\nInstall optional tooling: Revise, Documenter, Plots, IJulia.\nRun the test suite (julia --project -e 'using Pkg; Pkg.test()') before opening a merge request.","category":"page"},{"location":"contributing/#Coding-standards","page":"Contributor Guide","title":"Coding standards","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Prefer explicit imports (import .Module: function) and keep docstrings up to date with argument/keyword descriptions.\nUse ASCII unless physics notation requires otherwise.\nAdd concise comments ahead of non-trivial code blocks explaining the intent.","category":"page"},{"location":"contributing/#Documentation-workflow","page":"Contributor Guide","title":"Documentation workflow","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Update or create doc pages in extra/docs/src/.\nWhen adding notebooks or examples, include a short README summarising usage and runtime expectations.\nRun julia --project=extra/docs/ make.jl to preview the docs locally.","category":"page"},{"location":"contributing/#Branching-and-commits","page":"Contributor Guide","title":"Branching and commits","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Work on topic branches (docs/tutorial-structure, feat/meanfield-update).\nKeep commits focused; describe both intent and scope.\nReference related issues in commit messages when relevant.","category":"page"},{"location":"contributing/#Review-checklist","page":"Contributor Guide","title":"Review checklist","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Tests pass and new functionality has coverage (unit tests or runnable examples).\nDocumentation reflects API changes and links to newly created artefacts.\nExamples run end-to-end or include notes about outstanding validation steps.","category":"page"},{"location":"contributing/#Release-coordination","page":"Contributor Guide","title":"Release coordination","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Before tagging a release, ensure the docs build cleanly and all relevant hyperlinks resolve.","category":"page"},{"location":"contributing/#Getting-help","page":"Contributor Guide","title":"Getting help","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Open a discussion or issue with context (Julia version, environment, stack trace).\nTag module maintainers when code touches their area.","category":"page"},{"location":"advanced/#Advanced-Workflows","page":"Advanced Workflows","title":"Advanced Workflows","text":"","category":"section"},{"location":"advanced/","page":"Advanced Workflows","title":"Advanced Workflows","text":"Guidance for scaling calculations, running on clusters, and organising outputs.","category":"page"},{"location":"advanced/#Performance-playbook","page":"Advanced Workflows","title":"Performance playbook","text":"","category":"section"},{"location":"advanced/","page":"Advanced Workflows","title":"Advanced Workflows","text":"Profile hotspots with Julia's built-in tools (@time, @allocated, Profile).\nPrefer sparse vs. dense representations according to system size; use TightBinding.hopdim to estimate memory needs before allocating.\nFor very large problems, consider chunking k‑grids and streaming results to disk (HDF5/JLD2) for decoupled plotting.","category":"page"},{"location":"advanced/#Parallel-and-HPC-execution","page":"Advanced Workflows","title":"Parallel & HPC execution","text":"","category":"section"},{"location":"advanced/","page":"Advanced Workflows","title":"Advanced Workflows","text":"Twisted bilayer workloads benefit from HPC resources. Use extra/examples/twistedgraphene_slurm/submission_script.sh as a starting template, and update resource requests (nodes, walltime) once validated.\nRecord successful job configurations (cluster name, Julia/BLAS settings) to help others reproduce results.","category":"page"},{"location":"advanced/#Data-management","page":"Advanced Workflows","title":"Data management","text":"","category":"section"},{"location":"advanced/","page":"Advanced Workflows","title":"Advanced Workflows","text":"Store heavy outputs (HDF5, JLD2) under clearly named folders (e.g. output/<date>_<description>/). Keep repository footprint manageable by tracking derived artefacts through git-lfs or external storage where needed.\nInclude README files in data directories summarising provenance and parameter choices.","category":"page"},{"location":"advanced/#Troubleshooting-checklist","page":"Advanced Workflows","title":"Troubleshooting checklist","text":"","category":"section"},{"location":"advanced/","page":"Advanced Workflows","title":"Advanced Workflows","text":"Long runtimes: Verify sparse vs. dense representations, reduce k-point density, or truncate Floquet harmonics.\nMemory spikes: Inspect intermediate allocations (use @time, @allocated); split calculations into batches if necessary.\nNumerical instabilities: Tighten or loosen convergence tolerances, switch mixing strategies, or seed from prior converged states.","category":"page"},{"location":"advanced/#Work-in-progress-tracking","page":"Advanced Workflows","title":"Work-in-progress tracking","text":"","category":"section"},{"location":"advanced/","page":"Advanced Workflows","title":"Advanced Workflows","text":"Track gaps and ideas in your issue tracker; link scripts and figures so others can reproduce and review changes.","category":"page"},{"location":"tutorials/meanfield/#Tutorial-6-—-Mean-field-Self-Consistency","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6 — Mean-field Self-Consistency","text":"","category":"section"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"Notebook: extra/tutorial/Tutorial6_Meanfield.ipynb","category":"page"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"Walk through self-consistent Hartree–Fock calculations on lattice models, capturing density and order-parameter evolution.","category":"page"},{"location":"tutorials/meanfield/#Learning-goals","page":"Tutorial 6: Mean-field Self-Consistency","title":"Learning goals","text":"","category":"section"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"Configure Meanfield problems using solveselfconsistent and solvehartreefock.\nSet up initial guesses with Meanfield.initialguess and customise convergence criteria.\nMonitor observables (charge imbalance, magnetisation) during iterations.\nPersist convergence logs and final density matrices for downstream analysis.","category":"page"},{"location":"tutorials/meanfield/#Prerequisites","page":"Tutorial 6: Mean-field Self-Consistency","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"Tutorials 1–2 for lattice and Hamiltonian construction.\nOptional: experience with the examples under extra/examples/graphene/hubbardmeanfield_*.","category":"page"},{"location":"tutorials/meanfield/#Workflow-outline","page":"Tutorial 6: Mean-field Self-Consistency","title":"Workflow outline","text":"","category":"section"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"Model definition — Prepare the lattice and base Hamiltonian; define the interaction channels (e.g. Hubbard U, nearest-neighbour coupling).\nInitial state — Use initialguess(lat; mode=:random, seed=...) or reuse previous converged densities.\nSolver invocation — Call solveselfconsistent(problem; maxiter, tol, mix=...) capturing the returned HartreeFock object.\nDiagnostics — Inspect hf.iterations, hf.free_energy, and custom logs written to disk; plot convergence trajectories.\nPost-processing — Export observables and convert density matrices using Operators.densitymatrix.jl utilities if needed.","category":"page"},{"location":"tutorials/meanfield/#Live-example","page":"Tutorial 6: Mean-field Self-Consistency","title":"Live example","text":"","category":"section"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"println(\"Converged: \", converged, \" with residual \", error)","category":"page"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"figdir = joinpath(pwd(), \"figures\")\nmkpath(figdir)\nnothing","category":"page"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"sublA, sublB = Operators.getoperator(lat, [\"sublatticeAspin\", \"sublatticeBspin\"])\nmA, mB = real.(Operators.magnetization(ρ_sol, [sublA, sublB], lat))\n(mA, mB)","category":"page"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"δM = mA - mB\nM = mA + mB\nprintln(\"|M| = \", norm(M), \" |δM| = \", norm(δM))","category":"page"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"# Mean-field bands (use HMF.hMF, shifted by μ), coloured by sz for comparison\nbands_mf = getbands(HMF.hMF, ks, sz)\nbands_mf.bands .-= HMF.μ\np2 = plot(bands_mf; markersize=2, size=(380, 240), title=\"Hubbard mean-field\")\np = plot(p1, p2; size=(780, 260), titlefont=font(8))\nsavefig(p, joinpath(figdir, \"meanfield_bands_compare.svg\"))\nnothing","category":"page"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"(Image: )","category":"page"},{"location":"tutorials/meanfield/#Triangular-lattice-snapshot","page":"Tutorial 6: Mean-field Self-Consistency","title":"Triangular lattice snapshot","text":"","category":"section"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"lat_tri = Geometries.triangular_supercell()\nplot(lat_tri, size=(320, 220))","category":"page"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"base_tri = Operators.nearestneighbor!(Hops(), lat_tri)\nh_tri = Utils.dense(TightBinding.addspin(base_tri, :spinhalf))\nv_tri = Operators.gethubbard(lat_tri; mode=:σx, a=0.5, U=4.0)\nρ_init_tri = Meanfield.initialguess(v_tri, :random; lat=lat_tri)\nρ_tri, _, HMF_tri, converged_tri, _ = Meanfield.solvehartreefock(\n    h_tri, v_tri, ρ_init_tri, 0.5;\n    klin=16, iterations=120, tol=1e-4, show_trace=false\n)\nprintln(\"Triangular converged: \", converged_tri)","category":"page"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"ks_tri = kpath(lat_tri; num_points=140)\nbands_tri = getbands(HMF_tri.hMF, ks_tri)\nbands_tri.bands .-= HMF_tri.μ\np = plot(bands_tri; size=(360, 220), xlabel=\"k\", ylabel=\"ε/t\")\nsavefig(p, joinpath(figdir, \"triangular_meanfield.svg\"))\nnothing","category":"page"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"(Image: )","category":"page"},{"location":"tutorials/meanfield/#Validation-checklist","page":"Tutorial 6: Mean-field Self-Consistency","title":"Validation checklist","text":"","category":"section"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"Ensure convergence thresholds are satisfied and iterations do not oscillate.\nCompare final energies against reference runs (extra/examples/graphene).\nSave density matrices to output/ and verify they can be reloaded.","category":"page"},{"location":"tutorials/meanfield/#Suggested-extensions","page":"Tutorial 6: Mean-field Self-Consistency","title":"Suggested extensions","text":"","category":"section"},{"location":"tutorials/meanfield/","page":"Tutorial 6: Mean-field Self-Consistency","title":"Tutorial 6: Mean-field Self-Consistency","text":"Benchmark serial vs. threaded performance and note runtime/memory settings.\nIntegrate with twisted bilayer calculations (twistedgraphene_scf example).\nInvestigate superconducting order parameters by coupling to the Superconductivity module.","category":"page"},{"location":"tutorials/#Tutorials-Overview","page":"Overview","title":"Tutorials Overview","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"LatticeQM provides a sequence of Jupyter notebooks in extra/tutorial/ that walk through progressively more advanced workflows. Each documentation page in this section mirrors a notebook, highlighting the learning goals, main API calls, and checkpoints to verify that results look sensible.","category":"page"},{"location":"tutorials/#Running-the-notebooks","page":"Overview","title":"Running the notebooks","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"Launch Julia in the project environment:\njulia --project=.\nusing Pkg; Pkg.instantiate()\nStart Jupyter (or VS Code) with the instantiated environment:\nusing IJulia; notebook(dir=\"extra/tutorial\")\nExecute cells in order. When a tutorial saves artefacts (plots, HDF5 files, logs), they appear alongside the notebook or within its output/ subfolder.","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"If you prefer a headless run to validate the notebooks, you can automate notebook execution with a simple Julia script and review the generated artefacts.","category":"page"},{"location":"tutorials/#Tutorial-roadmap","page":"Overview","title":"Tutorial roadmap","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"# Topic Notebook Highlights Notes\n1 Structure & Geometry Tutorial1_Structure.ipynb Build lattices from scratch, explore predefined geometries, render 2D layouts. Establishes terminology used throughout the docs.\n2 Band Structures Tutorial2_Bands.ipynb Construct graphene Hamiltonians, sample Brillouin-zone paths, plot band dispersions. Reuses geometries from Tutorial 1.\n3 Haldane Model & Topology Tutorial3_Haldane.ipynb Add topological mass terms, compute Chern numbers, visualise edge modes. Introduces topology utilities.\n4 Twisted Bilayer Graphene Tutorial4_Twisted.ipynb Build large moiré lattices, compare continuum and lattice approaches, manage memory footprint. Tutorial4_Twisted2/3 capture experimental variations—treat their outputs as provisional until revalidated.\n5 Hofstadter Butterfly Tutorial5_Hofstadter.ipynb Thread magnetic flux, generate Hofstadter spectra, analyse fractal band structures. Heavy k-point sampling; expect longer runtimes.\n6 Mean-field Self-Consistency Tutorial6_Meanfield.ipynb Run Hartree–Fock loops, inspect convergence metrics, export density matrices. Shares utilities with extra/examples/graphene/hubbardmeanfield_*.\n7 Floquet Dynamics Tutorial7_Floquet.ipynb Construct time-periodic drives, compute quasienergy spectra, monitor resonances. Builds on modules co-authored with Tobias Kästli.","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"For background reading and additional implementation details, cross-reference the Concept Guides and the repository examples under extra/examples/.","category":"page"},{"location":"tutorials/structure/#Tutorial-1-—-Structure-and-Geometry","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1 — Structure & Geometry","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"Notebook: extra/tutorial/Tutorial1_Structure.ipynb","category":"page"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"This tutorial introduces lattice construction in LatticeQM, from specifying primitive vectors manually to using the extensive catalogue under LatticeQM.Geometries. By the end you will be comfortable building lattices, inspecting their coordinates, and producing quick sanity plots.","category":"page"},{"location":"tutorials/structure/#Learning-goals","page":"Tutorial 1: Structure & Geometry","title":"Learning goals","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"Understand how LatticeQM.Structure encodes lattice vectors and orbital positions.\nInstantiate standard geometries (square, honeycomb, multilayer stacks).\nVisualise sites and bonds for 2D systems and inspect neighbour shells.","category":"page"},{"location":"tutorials/structure/#Prerequisites","page":"Tutorial 1: Structure & Geometry","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"Julia basics and familiarity with matrix/vector notation.\nPlots.jl installed (Pkg.add(\"Plots\")) for quick visual checks.","category":"page"},{"location":"tutorials/structure/#Workflow-outline","page":"Tutorial 1: Structure & Geometry","title":"Workflow outline","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"Manual lattices — Define primitive vectors and fractional coordinates, e.g. lat = Lattice([1 0; 0 1], [[0, 0] [0.5, 0.5]]).\nPredefined geometries — Load helpers such as lat = Geometries.honeycomb() or Geometries.honeycomb_twisted(n).\nInspection utilities — Query Structure.coordinates(lat), Structure.getA(lat), or Structure.get_positions(lat) to confirm unit cell data.\nNeighbour analysis — Use Structure.getneighbors(lat; cutoff=...) to tabulate bonds or export them to downstream calculations.\nPlotting — Render a quick layout with plot(lat; repeat=[0:1,0:1]) to confirm angular orientation and stacking.","category":"page"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"Note on coordinates: Structure.Lattices.coordinates(lat) returns fractional positions in units of lattice vectors. Use Structure.Lattices.positions(lat) to obtain Cartesian coordinates (A * coordinates).","category":"page"},{"location":"tutorials/structure/#Live-example-—-manual-construction","page":"Tutorial 1: Structure & Geometry","title":"Live example — manual construction","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"figdir = joinpath(pwd(), \"figures\")\nmkpath(figdir)\nnothing","category":"page"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"println(\"Lattice vectors A =\")\nStructure.Lattices.getA(lat)","category":"page"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"println(\"First few fractional coordinates =\")\nStructure.Lattices.coordinates(lat)[:, 1:2]","category":"page"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"p = plot(lat; repeat=[0:2, 0:2], axis=false, framestyle=:none, size=(420, 320))\nsavefig(p, joinpath(figdir, \"honeycomb_layout.svg\"))\nnothing","category":"page"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"(Image: )","category":"page"},{"location":"tutorials/structure/#Programmatic-unit-cells","page":"Tutorial 1: Structure & Geometry","title":"Programmatic unit cells","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"using LinearAlgebra\nmanual = Structure.Lattices.Lattice()\nStructure.Lattices.addbasis!(manual, [1, 0, 0])\nStructure.Lattices.addbasis!(manual, [0, 1, 0])\nStructure.Lattices.addbasis!(manual, [0, 0, 1], :finite)\nStructure.Lattices.addextra!(manual, \"sublattice\")\nStructure.Lattices.addorbitals!(manual, [[0, 0, 0.0, 0] [0.5, 0.5, 0.2, 1]])\nStructure.Lattices.coordinates(manual)","category":"page"},{"location":"tutorials/structure/#Pre-defined-lattice-helpers","page":"Tutorial 1: Structure & Geometry","title":"Pre-defined lattice helpers","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"lat_sq = Geometries.square()\nlat_hc = Geometries.honeycomb()\np = plot(\n    plot(lat_sq; repeat=[0:3, 0:3], title=\"Square\", size=(360, 260)),\n    plot(lat_hc; repeat=[0:3, 0:3], title=\"Honeycomb\", size=(360, 260)),\n    size=(760, 280)\n)\nsavefig(p, joinpath(figdir, \"predefined_lattices.svg\"))\nnothing","category":"page"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"(Image: )","category":"page"},{"location":"tutorials/structure/#Superlattices-and-custom-filtering","page":"Tutorial 1: Structure & Geometry","title":"Superlattices and custom filtering","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"lat_super = Structure.Lattices.superlattice(lat, [[5, -5] [5, 5]])\nStructure.Lattices.foldPC!(lat_super)\nplot(lat_super, \"sublattice\"; repeat=[0:2, 0:2], size=(380, 280))","category":"page"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"import LinearAlgebra: norm\nfunction honeycomb_holes(; N=12, radius=0.27)\n    base = Geometries.honeycomb()\n    Structure.Lattices.translate!(base, [1/3, 1/3, 0])\n    expanded = Structure.Lattices.superlattice(base, [[N, 0] [0, N]])\n    Structure.Lattices.foldPC!(expanded)\n    keep = map(x -> norm(x) > radius * norm(Structure.Lattices.getA(expanded)[:, 1]), eachcol(Structure.Lattices.positions(expanded)))\n    idx = findall(keep)\n    expanded.spacecoordinates = expanded.spacecoordinates[:, idx]\n    expanded.extracoordinates = expanded.extracoordinates[:, idx]\n    expanded\nend\nlat_holes = honeycomb_holes(N=12, radius=0.27)\nplot(lat_holes, \"sublattice\"; markersize=2, repeat=[0:2, 0:2], size=(380, 280))","category":"page"},{"location":"tutorials/structure/#Ribbon-reductions","page":"Tutorial 1: Structure & Geometry","title":"Ribbon reductions","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"lat_arm = Structure.Lattices.reduceto1D(Geometries.honeycomb(), [[1, 1] [12, -12]])\nplot(lat_arm, \"sublattice\"; supercell=[48], markersize=2, size=(420, 280))","category":"page"},{"location":"tutorials/structure/#Validation-checklist","page":"Tutorial 1: Structure & Geometry","title":"Validation checklist","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"Do generated plots match the expected symmetry (e.g. honeycomb sublattices)?\nAre neighbour counts stable when you tweak the cutoff?\nAfter saving figures, confirm they appear in extra/tutorial/output/.","category":"page"},{"location":"tutorials/structure/#Suggested-extensions","page":"Tutorial 1: Structure & Geometry","title":"Suggested extensions","text":"","category":"section"},{"location":"tutorials/structure/","page":"Tutorial 1: Structure & Geometry","title":"Tutorial 1: Structure & Geometry","text":"Swap in Geometries.triangular() or Geometries.square() to compare coordination.\nAttach custom metadata (e.g. layer labels) via the extra_dimensions keyword.\nFeed lattices directly into Operators.graphene and continue with Tutorial 2.","category":"page"},{"location":"guides/geometry/#Concept-Guide-—-Geometry-and-Lattices","page":"Geometry & Lattices","title":"Concept Guide — Geometry & Lattices","text":"","category":"section"},{"location":"guides/geometry/","page":"Geometry & Lattices","title":"Geometry & Lattices","text":"This guide expands on Tutorial 1 with additional context about how LatticeQM represents lattices, handles dimensionality, and exposes helper utilities.","category":"page"},{"location":"guides/geometry/#Core-types","page":"Geometry & Lattices","title":"Core types","text":"","category":"section"},{"location":"guides/geometry/","page":"Geometry & Lattices","title":"Geometry & Lattices","text":"Structure.Lattice: stores primitive vectors (A), fractional coordinates, and optional extra dimensions (e.g. layer labels, z offsets).\nStructure.Geometries: collection of convenience constructors for common lattices (honeycomb, triangular, square, multilayer stacks).\nStructure.Lattices: lower-level factory supporting programmatic lattice generation.","category":"page"},{"location":"guides/geometry/#Constructing-lattices","page":"Geometry & Lattices","title":"Constructing lattices","text":"","category":"section"},{"location":"guides/geometry/","page":"Geometry & Lattices","title":"Geometry & Lattices","text":"lat = Lattice([1 0; 0 1], [[0, 0] [0.5, 0.5]])   # square lattice with two sites\nlat3d = Lattice([[1,0,0] [0,1,0] [0,0,1]])       # cubic lattice\ntwisted = Geometries.honeycomb_twisted(13)       # moiré honeycomb (θ ≈ 1.05°)","category":"page"},{"location":"guides/geometry/","page":"Geometry & Lattices","title":"Geometry & Lattices","text":"Use the optional extra_dimensions keyword to attach metadata: Lattice(A, coords; extra_dimensions=[\"layer\"]).\nPrefer Geometries helper functions for well-tested configurations; inspect their docstrings for supported keywords (strain, offsets, stacking).","category":"page"},{"location":"guides/geometry/#Neighbours-and-symmetry","page":"Geometry & Lattices","title":"Neighbours and symmetry","text":"","category":"section"},{"location":"guides/geometry/","page":"Geometry & Lattices","title":"Geometry & Lattices","text":"Structure.getneighbors(lat; cutoff, order) returns neighbour shells with displacement vectors—essential for building hoppings.\nStructure.brillouinzone(lat) and Structure.highsymmetrypoints(lat) help generate k-paths aligned with lattice symmetries.\nStructure.symmetries(lat) (where available) exposes point-group data; leverage it to reduce computational workloads.","category":"page"},{"location":"guides/geometry/#Visualisation","page":"Geometry & Lattices","title":"Visualisation","text":"","category":"section"},{"location":"guides/geometry/","page":"Geometry & Lattices","title":"Geometry & Lattices","text":"using Plots\nplot(lat; repeat=[0:1, 0:1], bonds=true, legends=false)","category":"page"},{"location":"guides/geometry/","page":"Geometry & Lattices","title":"Geometry & Lattices","text":"For multilayer systems, use the LayeredLayouts recipes in Plotting to separate layers vertically.\nExport figures alongside scripts (mkpath(\"output\"); savefig(\"output/lat.svg\")) to keep provenance.","category":"page"},{"location":"guides/geometry/#Best-practices","page":"Geometry & Lattices","title":"Best practices","text":"","category":"section"},{"location":"guides/geometry/","page":"Geometry & Lattices","title":"Geometry & Lattices","text":"Avoid mutating lattice internals directly; instead use Structure.update_spacecoordinates! or Structure.update_A!.\nDocument any custom lattice constructors and add them to Geometries when stable so users can discover them via the API reference.\nCross-reference the extra/examples/ scripts to showcase non-standard lattices (e.g. TMDs, triangular Hubbard models).","category":"page"},{"location":"guides/meanfield/#Concept-Guide-—-Mean-field-and-Superconductivity","page":"Mean-field & Superconductivity","title":"Concept Guide — Mean-field & Superconductivity","text":"","category":"section"},{"location":"guides/meanfield/","page":"Mean-field & Superconductivity","title":"Mean-field & Superconductivity","text":"The Meanfield and Superconductivity modules implement Hartree–Fock and Bogoliubov–de Gennes (BdG) workflows. This guide collects best practices and links relevant examples.","category":"page"},{"location":"guides/meanfield/#Mean-field-toolkit","page":"Mean-field & Superconductivity","title":"Mean-field toolkit","text":"","category":"section"},{"location":"guides/meanfield/","page":"Mean-field & Superconductivity","title":"Mean-field & Superconductivity","text":"Meanfield.solveselfconsistent(problem; kwargs...): generic interface for iterative solvers (density, spin, pairing).\nMeanfield.solvehartreefock(model; kwargs...): Hartree–Fock convenience wrapper returning a HartreeFock object.\nMeanfield.initialguess(lat; mode=:random) produces seed density matrices; a deterministic :uniform mode is available for benchmarking.\nMeanfield.HartreeFock struct exposes fields such as density, energies, iterations, and converged.","category":"page"},{"location":"guides/meanfield/#Superconducting-extension","page":"Mean-field & Superconductivity","title":"Superconducting extension","text":"","category":"section"},{"location":"guides/meanfield/","page":"Mean-field & Superconductivity","title":"Mean-field & Superconductivity","text":"Superconductivity.BdGOperator builds Bogoliubov–de Gennes Hamiltonians from normal-state hoppings and pairing matrices.\nPairing helpers (s-wave, d-wave) are available under Superconductivity—audit docstrings as you standardise them.","category":"page"},{"location":"guides/meanfield/#Typical-workflow","page":"Mean-field & Superconductivity","title":"Typical workflow","text":"","category":"section"},{"location":"guides/meanfield/","page":"Mean-field & Superconductivity","title":"Mean-field & Superconductivity","text":"Model definition — Specify the lattice, base hopping matrices, and interaction parameters (onsite U, nearest-neighbour V, pairing strength).\nInitial guess — Use initialguess or reuse converged densities from previous runs (hf.density).\nIteration control — Tune maxiter, tol, and mixing (linear, Anderson). Monitor hf.residuals.\nPost-processing — Export densities, order parameters, and energies using Operators.densitymatrix utilities or custom writers.\nVisualisation — Plot layer/sublattice resolved densities; cross-check with scripts under extra/examples/ for consistency.","category":"page"},{"location":"guides/meanfield/#Debugging-convergence","page":"Mean-field & Superconductivity","title":"Debugging convergence","text":"","category":"section"},{"location":"guides/meanfield/","page":"Mean-field & Superconductivity","title":"Mean-field & Superconductivity","text":"Inspect the residual history; oscillations often indicate the need for stronger damping or a better initial guess.\nUse tmp_debug.jl or dedicated sandbox notebooks to isolate problematic parameter sets before committing changes.\nLog solver metadata (mixing coefficients, runtime) to aid reproducibility.","category":"page"},{"location":"guides/meanfield/#Resources","page":"Mean-field & Superconductivity","title":"Resources","text":"","category":"section"},{"location":"guides/meanfield/","page":"Mean-field & Superconductivity","title":"Mean-field & Superconductivity","text":"Examples: extra/examples/graphene/hubbardmeanfield_*, extra/examples/twistedgraphene_scf.\nTutorials: Tutorial 6 for a hands-on walkthrough.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This reference is generated from in‑source docstrings. Use Julia help mode (?name) in the REPL for the most up‑to‑date signatures and keyword defaults. Where available, cross‑links to tutorials and guides provide usage context.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The sections below list public and internal names grouped by submodule. Use Julia’s help mode (?) for inline documentation and follow cross-links back to tutorials and guides for practical context.","category":"page"},{"location":"api/#Structure","page":"API Reference","title":"Structure","text":"","category":"section"},{"location":"api/#LatticeQM.Structure.rotation2D-Tuple{Any}","page":"API Reference","title":"LatticeQM.Structure.rotation2D","text":"rotation2D(θ)\n\nReturns the 2x2 rotation matrix R = R^T parametrized by the rotation angle θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.rotation3D","page":"API Reference","title":"LatticeQM.Structure.rotation3D","text":"rotation3D(θ, n=[0,0,1])\n\nReturns SO(3) rotation matrix parametrized by rotation angle θ and rotation axis n=[n1,n2,n3].\n\nNote: This routine will always normalize n.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.signedangle-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractVector)","page":"API Reference","title":"LatticeQM.Structure.signedangle","text":"signedangle(e1::T,e2::T; z=nothing)\n\nreturns the signed angle between 3D vectors e1 and e2. z should be the normal vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.Lattice","page":"API Reference","title":"LatticeQM.Structure.Lattices.Lattice","text":"Lattice\n\nType that contains all information about a lattice.\n\nFields\n\nbasis::Matrix: columns are basis vectors\nlatticedim::Int: how many of the basis vectors are lattice vectors\nspacecoordinates::Matrix: columns are coordinates of orbitals in the unit cell (w.r.t. basis vectors)\nextracoordinates::Matrix: additional non-spatial coordinates (e.g., could be sublattice index)\nextralabels::Dict: labels for the non-spatial coordinates\nspecialpoints::LabeledPoints: High-symmetry points of the lattice (see ?Structure.Paths.LabeledPoints)\n\nConstructors\n\nLattice(basis::Matrix)\nLattice(basis::Matrix [, latticedim::Int], spacecoordinates::Matrix [, extracoordinates::Matrix]; extralabels=Vector{String}(), specialpoints=LabeledPoints())\n\nProperty functions\n\nlatticedim(lat::Lattice)\ncountorbitals(lat:Lattice)\nspacedim(lat::Lattice)\nextraspacedim(lat::Lattice)\n\nhasdimension(lat::Lattice, name::String)\nassertdimension(lat::Lattice, name::String)\n\nbasis(lat::Lattice, ...)\ngetA(lat::Lattice, ...)\ngetB(lat::Lattice, ...)\n\ncoordinates(lat::Lattice, ...)\npositions(lat::Lattice, ...)\nallpositions(lat::Lattice, ...)\nextracoordinates(lat::Lattice, ...)\n\nfilterindices(lat::Lattice, name::String, condition::Function)\n\nMethod functions\n\naddbasis!\naddorbital!\naddorbitals!\naddextra!\nsetextracoordinates!\nfractionalize!\nfoldfractional\nfoldcoordinates!\nrotatebasis!\nrotatecoordinates!\ntranslate!\ndisplace!\ndisplaceZ!\nmirrorZ!\nmirrorZ\nnewdimension!\nmergelattices!\nmergelattices\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeQM.Structure.Lattices.bistack-Tuple{LatticeQM.Structure.Lattices.Lattice, Float64}","page":"API Reference","title":"LatticeQM.Structure.Lattices.bistack","text":"bistack(lat, δz; fracshift=[0.0, 0.0])\n\nCreate a bilayer by duplicating lat and offsetting the upper copy by δz along the third (z) coordinate. Optionally shift the second layer in fractional in‑plane coordinates by fracshift before stacking. Adds a \"z\" extra coordinate if missing. Returns the new stacked Lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.crop2unitcell!-Tuple{LatticeQM.Structure.Lattices.Lattice}","page":"API Reference","title":"LatticeQM.Structure.Lattices.crop2unitcell!","text":"crop2unitcell!(lat)\n\nRemove orbitals whose fractional coordinates fall outside [0,1) along the primitive directions. Operates in place and returns lat.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.crop2unitcell-Tuple{AbstractMatrix, AbstractMatrix}","page":"API Reference","title":"LatticeQM.Structure.Lattices.crop2unitcell","text":"crop2unitcell(positions, Λ)\n\nReturn the subset of positions (Cartesian) that lie inside the primitive unit cell spanned by Λ (direct basis). Returns a matrix whose columns are the kept positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.displace!-Tuple{Any, Function}","page":"API Reference","title":"LatticeQM.Structure.Lattices.displace!","text":"displace!(lat, f::Function)\n\nFunction f takes orbital i at position pi and displaces it by vector vi = f(p_i).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.displaceZ!-Tuple{Any, Function}","page":"API Reference","title":"LatticeQM.Structure.Lattices.displaceZ!","text":"displaceZ!(lat, f::Function)\n\nFunction f takes orbital i at position pi and displaces it in the third coodinate by zi = f(p_i).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.fillregion-Tuple{LatticeQM.Structure.Lattices.Lattice, Function}","page":"API Reference","title":"LatticeQM.Structure.Lattices.fillregion","text":"fillregion(lat::Lattice, f::Function)\n\nTakes the d-dimensional lattice and tiles the d-dimensional region defined by function f. Returns a 0-dimensional lattice (single unit cell with no periodicities).\n\nf(p)=true if point p belongs to the region and f(p)=false otherwise\n\nNote: f must define a finite region that includes the origin.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.foldBZ!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice}","page":"API Reference","title":"LatticeQM.Structure.Lattices.foldBZ!","text":"foldBZ!(points, lat::Lattice; shift=0.0)\n\nFold k‑points (columns of points) into the first Brillouin zone of lattice lat. K‑points are assumed to be in fractional (reciprocal‑basis) coordinates. An optional shift vector can be subtracted before folding.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.foldPC!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice}","page":"API Reference","title":"LatticeQM.Structure.Lattices.foldPC!","text":"foldPC!(points, lat::Lattice; shift=0.0)\n\nFold lattice coordinates (columns of points) into the first primitive unit cell of lat. Coordinates must be fractional in the direct‑lattice basis. An optional shift vector can be subtracted before folding.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.foldPC!-Tuple{LatticeQM.Structure.Lattices.Lattice}","page":"API Reference","title":"LatticeQM.Structure.Lattices.foldPC!","text":"foldPC!(lat::Lattice; shift=0.0)\n\nIn‑place variant that folds lat.spacecoordinates into the first primitive unit cell of lat. Coordinates are interpreted as fractional. Returns the folded coordinate submatrix view for convenience.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.foldcell!-Tuple{AbstractMatrix{Float64}, Matrix{Float64}}","page":"API Reference","title":"LatticeQM.Structure.Lattices.foldcell!","text":"foldcell!(points::AbstractMatrix{Float64}, basis::Matrix{Float64})\n\nFold columns of points into the first primitive unit cell defined by the column vectors of basis (direct-lattice basis). Internally constructs neighbor-cell vectors via getneighborcells and calls foldcell_fromneighbors! with the metric basis' * basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.foldcell_fromneighbors!-Tuple{AbstractMatrix{Float64}, Matrix{Float64}}","page":"API Reference","title":"LatticeQM.Structure.Lattices.foldcell_fromneighbors!","text":"foldcell_fromneighbors!(points, gvectors[, M])\n\nFold columns of points into the first Wigner–Seitz cell using a list of neighbor-cell vectors gvectors (both in fractional coordinates). The optional metric M = B'B can be supplied to define distances in a non-orthogonal basis, where B = [G1 G2 …] collects the reciprocal lattice vectors as columns.\n\nArguments\n\npoints::AbstractMatrix{Float64}: columns are coordinates to be folded (fractional units, i.e. in the basis of the lattice vectors).\ngvectors::Matrix{Float64}: columns are the neighbor-cell shift vectors that span the Wigner–Seitz region (fractional units).\nM::AbstractMatrix (optional): metric used to compute distances; defaults to the identity (orthonormal basis).\n\nReturns the same points matrix with all columns folded in place. This is the low‑level implementation used by higher‑level foldcell! methods.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.getB","page":"API Reference","title":"LatticeQM.Structure.Lattices.getB","text":"Calculate the dual lattice of lat.A. Here we use the general formula B = A * (A^T * A)^-1. That works also  when the d-dim lattice is embedded in D-dim space.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Lattices.getneighborBZ-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Structure.Lattices.getneighborBZ","text":"getneighborBZ(lat, k=1; halfspace=true, innerpoints=false, excludeorigin=true)\n\nThis is the analogue of method getneighborcells(), except that it looks for  nearest neighbor cells in reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.getneighborcells","page":"API Reference","title":"LatticeQM.Structure.Lattices.getneighborcells","text":"getneighborcells(A, k=1; halfspace=true, innerpoints=false, excludeorigin=true)\n\nA naive implementation to find a list of k-th-nearest neighboring unit cells given lattice vectors A[:,i]. If halfspace=true, the list only contain [I,J] without its partner [-I,-J]. If innerpoints=true, returns all neighboring cells up to and including the k-th ones.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Lattices.getneighborcells-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Structure.Lattices.getneighborcells","text":"getneighborcells(lat, k=1; halfspace=true, innerpoints=false, excludeorigin=true)\n\nA naive implementation to find a list of k-th-nearest neighboring unit cells. If halfspace=true, the list only contain [I,J] without its partner [-I,-J]. If innerpoints=true, returns all neighboring cells up to and including the k-th ones.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.repeat","page":"API Reference","title":"LatticeQM.Structure.Lattices.repeat","text":"repeat(spacecoordinates[, Λ], repeat=[0:0, 0:0])\n\nTile a set of point coordinates by integer translations of the lattice. Returns the concatenated coordinate matrix.\n\nArguments\n\nspacecoordinates::AbstractMatrix: columns are point positions in Cartesian space.\nΛ::AbstractMatrix (optional): direct lattice basis (defaults to 2D identity).\nrepeat::Vector{<:AbstractRange}: ranges along a1 and a2, e.g. [0:1, 0:1] for 2×2.\n\nExample\n\ncoords2x2 = repeat(coords, A, [0:1, 0:1])\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Lattices.sortposition!","page":"API Reference","title":"LatticeQM.Structure.Lattices.sortposition!","text":"sortposition!(lat, name::String[, sortfunc])\n\nSort orbitals by an extra coordinate name (e.g. \"z\", \"sublattice\"). Useful for layered plots so that layers appear in front/back order. Returns the permutation applied.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Lattices.sortposition!-2","page":"API Reference","title":"LatticeQM.Structure.Lattices.sortposition!","text":"sortposition!(lat, index::Int[, sortfunc])\n\nIndex‑based variant of sortposition!, using the index‑th extra coordinate. Returns the permutation applied.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Lattices.supercellpoints-Tuple{Matrix{Int64}}","page":"API Reference","title":"LatticeQM.Structure.Lattices.supercellpoints","text":"supercellpoints(M::AbstractMatrix{Int}; offset::Float64=sqrt(eps()))\n\nGiven an integer lattice Z^D and an integer matrix M describing a (possibly non‑orthogonal) superlattice, return the integer points inside one supercell of the new lattice. The number of columns equals abs(det(M)).\n\nThe small offset avoids boundary ambiguities for points lying exactly on cell faces.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.superlattice-Tuple{LatticeQM.Structure.Lattices.Lattice, Matrix{Int64}, Matrix{Int64}}","page":"API Reference","title":"LatticeQM.Structure.Lattices.superlattice","text":"superlattice(lat::Lattice, S::Matrix{Int}, supercellints::Matrix{Int}; kwargs...)\n\nLow‑level constructor where the integer coordinates inside one supercell are pre‑computed and provided as supercellints (columns). Not intended for general users.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Lattices.superlattice-Tuple{LatticeQM.Structure.Lattices.Lattice, Matrix{Int64}}","page":"API Reference","title":"LatticeQM.Structure.Lattices.superlattice","text":"superlattice(lat::Lattice, superperiods; kwargs...)\n\nConstruct a superlattice from lat.\n\nsuperperiods: either a vector of integers (scales each direct basis vector) or an integer matrix S whose columns define the linear transformation of the primitive basis, i.e. the new basis is A * S.\n\nCopies atoms into the new supercell and returns a new Lattice with updated coordinates and specialpoints preserved. Extra coordinates (e.g. sublattice, layer, z) are replicated.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Geometries.graphene-Tuple{}","page":"API Reference","title":"LatticeQM.Structure.Geometries.graphene","text":"graphene()\n\nConvenience alias for honeycomb(1.42) using a typical C–C bond length in Ångström units.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Structure.Geometries.honeycomb","page":"API Reference","title":"LatticeQM.Structure.Geometries.honeycomb","text":"honeycomb(a=1.0)\n\nTwo‑site honeycomb (graphene) lattice with lattice constant a (distance between nearest neighbors equals a). Adds a \"sublattice\" extra coordinate with values 0 (A) and 1 (B).\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.honeycomb_AA","page":"API Reference","title":"LatticeQM.Structure.Geometries.honeycomb_AA","text":"honeycomb_AA(a=1.0, z=3.0)\n\nAA‑stacked honeycomb bilayer with interlayer distance z.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.honeycomb_AB","page":"API Reference","title":"LatticeQM.Structure.Geometries.honeycomb_AB","text":"honeycomb_AB(a=1.0, z=3.0)\n\nAB (Bernal) stacking for a honeycomb bilayer with interlayer distance z.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.honeycomb_ABC","page":"API Reference","title":"LatticeQM.Structure.Geometries.honeycomb_ABC","text":"honeycomb_ABC(a=1.0, z=3.0)\n\nABC (rhombohedral) stacked tri‑layer honeycomb. Adds \"sublattice\" and \"layer\" extra coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.honeycomb_BA","page":"API Reference","title":"LatticeQM.Structure.Geometries.honeycomb_BA","text":"honeycomb_BA(a=1.0, z=3.0)\n\nBA stacking variant for a honeycomb bilayer with interlayer distance z.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.honeycomb_bilayer","page":"API Reference","title":"LatticeQM.Structure.Geometries.honeycomb_bilayer","text":"honeycomb_bilayer(a=1.0, z=3.0; δ=[0.0, 0.0])\n\nBernal‑stacked honeycomb bilayer (AB) with interlayer distance z. Optional in‑plane shift δ (fractional coordinates) moves the top layer prior to stacking. Extra coordinate \"sublattice\" is provided.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.honeycomb_twisted","page":"API Reference","title":"LatticeQM.Structure.Geometries.honeycomb_twisted","text":"honeycomb_twisted(N, a=1.0, z=3.0; fold=true)\n\nCommensurate twisted bilayer graphene (TBG) with twist index N. If fold=true the structure is wrapped to the primitive cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.honeycomb_twisted_ABAB","page":"API Reference","title":"LatticeQM.Structure.Geometries.honeycomb_twisted_ABAB","text":"honeycomb_twisted_ABAB(N, a=1.0, z=3.0; fold=true)\n\nFour‑layer twisted stack with ABAB stacking within layers prior to twisting.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.honeycomb_twisted_ABBA","page":"API Reference","title":"LatticeQM.Structure.Geometries.honeycomb_twisted_ABBA","text":"honeycomb_twisted_ABBA(N, a=1.0, z=3.0; fold=true)\n\nFour‑layer twisted stack with ABBA stacking within layers prior to twisting.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.smoothdisplaceZ!","page":"API Reference","title":"LatticeQM.Structure.Geometries.smoothdisplaceZ!","text":"smoothdisplaceZ!(lat, δz_even=0.055, δz_odd=0.0; sharp=1)\n\nApply a smooth out‑of‑plane displacement pattern to a hexagonal bilayer lat parameterized by even/odd amplitudes. The optional sharp parameter controls the smoothness (higher values approach a sign‑like modulation).\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.square","page":"API Reference","title":"LatticeQM.Structure.Geometries.square","text":"square(a=1.0)\n\nSquare Bravais lattice with lattice constant a. Returns a Lattice with one orbital per cell and standard special k‑points (Γ, X, Y, M).\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.triangular","page":"API Reference","title":"LatticeQM.Structure.Geometries.triangular","text":"triangular(a=1.0)\n\nTriangular Bravais lattice with lattice constant a. Returns a Lattice with one orbital per cell and triangular‑lattice special points (Γ, K, M, …).\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.triangular_supercell","page":"API Reference","title":"LatticeQM.Structure.Geometries.triangular_supercell","text":"triangular_supercell(a=1.0)\n\nA 3‑site triangular supercell useful for toy models (e.g. Kekulé). Provides a \"sublattice\" extra label with values 1,2,3.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Structure.Geometries.triangular_twisted","page":"API Reference","title":"LatticeQM.Structure.Geometries.triangular_twisted","text":"triangular_twisted(N, a=1.0, z=3.0; fold=true)\n\nCommensurate twisted bilayer built from triangular lattices using twist index N (moiré periodicity). If fold=true, folds positions back to the primitive cell. Sets a compact set of special k‑points.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.LatticeQM","page":"API Reference","title":"LatticeQM.LatticeQM","text":"LatticeQM\n\nLibrary for tight-binding models defined on (periodic) lattices, providing  convenient functions to build the operators and to obtain bands, expectation values, topological indices, linear response coefficients and mean-field solutions.\n\nSubmodules\n\nStructure\nTightBinding \nSpectrum\nOperators\nLinearResponse\nMeanfield\n\nAny of these modules can be further explored, e.g., with ?TightBinding\n\nUsage examples\n\nSee folder examples of the package.\n\n\n\n\n\n","category":"module"},{"location":"api/#LatticeQM.Structure","page":"API Reference","title":"LatticeQM.Structure","text":"Structure\n\nProvides the struct Lattices.Lattice to define and manipulate lattices,  and Paths.DiscretePath to deal with discretized paths.\n\nCheck out the submodules:\n\nLattices\nPaths\nGeometries\n\n\n\n\n\n","category":"module"},{"location":"api/#LatticeQM.Structure.Lattices","page":"API Reference","title":"LatticeQM.Structure.Lattices","text":"Lattices\n\nProvides the type Lattice and methods that act on this struct, see ?Structure.Lattices.Lattice.\n\n\n\n\n\n","category":"module"},{"location":"api/#LatticeQM.Structure.Geometries","page":"API Reference","title":"LatticeQM.Structure.Geometries","text":"Geometries\n\nProvides predefined lattice objects (such as two-dimensional honeycomb lattice).\n\nExample\n\nimport Structure.Geometries\n\nlat = Geometries.honeycomb_twisted(11)\nplot(lat, 3; supercell=[0:1,0:1])\n\n\n\n\n\n","category":"module"},{"location":"api/#TightBinding","page":"API Reference","title":"TightBinding","text":"","category":"section"},{"location":"api/#LatticeQM.TightBinding.directsum-Tuple{Hops, Hops}","page":"API Reference","title":"LatticeQM.TightBinding.directsum","text":"Naive implementation of combining the linear spaces of two hopping models.\n\n\n\n\n\n","category":"method"},{"location":"api/#Operators","page":"API Reference","title":"Operators","text":"","category":"section"},{"location":"api/#LatticeQM.Operators.addhaldane!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Number}","page":"API Reference","title":"LatticeQM.Operators.addhaldane!","text":"addhaldane!(hops, lat, t2; ϕ=π/2, spinhalf=false, cellrange=1, mode=:none, zmode=:none)\n\nThis method is a somewhat inefficient way to compute the haldane hopping matrix. The only upside to it is that it uses methods that I already implemented and that it is fairly general.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.addsublatticeimbalance!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Real}","page":"API Reference","title":"LatticeQM.Operators.addsublatticeimbalance!","text":"addsublatticeimbalance!(hops, lat, Δ; kwargs...)\n\nAdd a sublattice‑staggered chemical potential (imbalance) of magnitude Δ to hops on lattice lat. Positive values raise A and lower B (by convention).\n\nNo‑op for Δ≈0.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.addvalley!","page":"API Reference","title":"LatticeQM.Operators.addvalley!","text":"addvalley!(hops, lat, fz=x->sign(x[3]+1e-3); kwargs...)\n\nAdd a valley mass term to hops on lat. Customise the layer sign via fz.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Operators.addzeeman!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Function}","page":"API Reference","title":"LatticeQM.Operators.addzeeman!","text":"addzeeman!(hops, lat, Mv::Function)\n\nAdd a site‑dependent Zeeman coupling defined by the vector field Mv(r) to hops on lattice lat. The operator acts in spin‑1/2 space via σ·M(r) at each site. Modifies hops in place and returns it.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.addzeeman!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Vector{Float64}}","page":"API Reference","title":"LatticeQM.Operators.addzeeman!","text":"addzeeman!(hops, lat, M::AbstractVector; format=:dense)\n\nAdd a uniform Zeeman field M = [Mx, My, Mz] (constant across the lattice). If the norm of M is (numerically) zero, this is a no‑op. Returns hops.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.blockmatrix!-Tuple{AbstractMatrix, Vector{Int64}, Vector{Int64}, AbstractVector{<:AbstractMatrix}}","page":"API Reference","title":"LatticeQM.Operators.blockmatrix!","text":"blockmatrix(mat, I, J, V)\nblockmatrix!(mat, I, J, V)\n\nWrites a sparse matrix from block matrices.\n\nN (Int): Size of the resulting N-times-N square matrix I,J (Vector{Int}): Row/Column coordinates vecofmats (Vector{Matrix}): Vector of block matrices (must be equal sized in the current implementation)\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.droplatdim-Tuple{Hops, Int64}","page":"API Reference","title":"LatticeQM.Operators.droplatdim","text":"reducelatdim(hops, index::Int)\n\nDrop a lattice dimension. For example, a two-dimensional lattice with lattice vectors a1, a2 can be turned into a 1D ribbon with lattice vector a1 by dropping all hoppings along a2 (index=2) or inteo a 1D with lattice vector a2 by dropping all hoppings along a1 (index=1).\n\nTip: Together with superlattice(hops, periods) one can control the width of the finite ribbon  before applying reducelatdim.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.getcurrentoperators-Tuple{LatticeQM.Structure.Lattices.Lattice, AbstractMatrix}","page":"API Reference","title":"LatticeQM.Operators.getcurrentoperators","text":"Returns current operators [J_α,...] for each spatial coordinate α=1,...,D\ngiven a Hamiltoinan of hopping elements `hops` and lattice structure `la`.\n\nThis should be the preferred way of generating a current operator for a given hopping Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.getcurrentoperators-Tuple{LatticeQM.Structure.Lattices.Lattice, Function}","page":"API Reference","title":"LatticeQM.Operators.getcurrentoperators","text":"Returns current operators [J_α,...] for each spatial coordinate α=1,...,D\ngiven a generating function t for the hopping elements of the respective Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.getcurrentoperators-Tuple{LatticeQM.Structure.Lattices.Lattice, Hops}","page":"API Reference","title":"LatticeQM.Operators.getcurrentoperators","text":"Returns current operators [J_α,...] for each spatial coordinate α=1,...,D\ngiven a Hamiltoinan of hopping elements `hops` and lattice structure `la`.\n\nThis should be the preferred way of generating a current operator for a given hopping Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.gethops-Tuple{LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Operators.gethops","text":"gethops(lat::Lattice, t::Function; cellrange=1, format=:auto, vectorized=false)\n\nIterates over pairs of orbitals/atom positions (r1,r2) in lattice lat and evaluates the hopping elements t(r1+R,r2) for each lattice vector R.\n\nBy default, vectorized=false. For huge systems use vectorized=true and make  sure the hopping function t accepts matrices as arguments. The keyword argument format can be :dense or :sparse. For :auto, small systems  will be dense and huge problems are assumed to be sparse.\n\nReturns the hopping elements in the format Dict(R => t_R)\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.getoperator-Tuple{LatticeQM.Structure.Lattices.Lattice, String, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Operators.getoperator","text":"getoperator(lat::Lattice, name::String, args...; kwargs...)\n\nReturn common projection/observable operators defined on lat by name.\n\nSupported names (case-insensitive where noted):\n\n\"sx\", \"sy\", \"sz\" (or \"MX/MY/MZ\", \"SX/SY/SZ\"): Spin Pauli components.\n\"spinup\", \"spindown\": Projectors onto ↑/↓ in the local spin basis.\n\"Sn\": Spin along custom axis via Sn(lat, n̂) (see keyword forms).\n\"layer\": Layer projector for multilayer geometries.\n\"sublattice\": A/B sublattice projector; also \"sublatticeA\", \"sublatticeB\".\n\"sublatticeAspin\", \"sublatticeBspin\": Sublattice-resolved spin projectors.\n\nFor interaction kernels (e.g. \"Hubbard\", \"CappedYukawa\"), use the dedicated constructors in Operators/Meanfield (see gethubbard, getcappedyukawa).\n\nReturns a Hops-like operator suitable for Spectrum.getbands projectors or expectation-value routines.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.getzeeman-Tuple","page":"API Reference","title":"LatticeQM.Operators.getzeeman","text":"getzeeman(lat, M; kwargs...)\n\nConstruct a Zeeman term as a Hops operator. M can be either a constant magnetic field vector [Mx, My, Mz] (units absorbed in gμB) or a function Mv(r) returning a 3‑vector at position r for spatially varying fields.\n\nUse addzeeman!(...) to add in place to an existing operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.hofstadter-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Int64}","page":"API Reference","title":"LatticeQM.Operators.hofstadter","text":"hofstadter(hops, lat, Q)\n\nDetermines the energie spectrum as function of rational magnetic flux Phi=pq, where p, q are coprime integers with 1<= q <= Q and 1<=p<q. Returns a list of fluxes and a list of energies at each flux.\n\nIn this implementation we evaluate at the Gamma-point of the magnetic cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.hofstadter_dos","page":"API Reference","title":"LatticeQM.Operators.hofstadter_dos","text":"hofstadter_dos(hops, lat, q_max::Int, (f_min, f_max), N=300)\n\nSee hofstadterdos(hops, lat, qmax, frequencies).\n\nReturns a list of fluxes, frequencies and a the dos at each flux.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Operators.hofstadter_dos-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Int64, AbstractVector}","page":"API Reference","title":"LatticeQM.Operators.hofstadter_dos","text":"hofstadter_dos(hops, lat, q_max::Int, frequencies::AbstractVector; klin=100, Γ=0.05)\n\nDetermines the energie spectrum as function of rational magnetic flux Phi=pq, where p, q are coprime integers with 1<= q <= qmax and 1<=p<q. Note that qmax determines the size of the largest magnetic supercell.\n\nThe density of states (DOS) at each flux is calculated on a discrete k-grid (resolution give by klin). The parameter Γ determines the energy broadening when calculating DOS.\n\nReturns a list of fluxes and a the dos at given frequencies at each flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.peierls!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, AbstractVector}","page":"API Reference","title":"LatticeQM.Operators.peierls!","text":"peierls!(hops, lat, B)\n\nAdd Peierls phases to operator hops on lattice geometry lat for the uniform magnetic field B=(B1,B2,B3). Uses Coulomb gauge, see uniformfieldphase(...).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.peierls!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Function}","page":"API Reference","title":"LatticeQM.Operators.peierls!","text":"peierls!(hops, lat, phase)\n\nThis method implements Peierl's substitution on a tight-binding model by adding the appropriate phases to each hopping amplitude in the Hamiltonian given by hops.\n\nThe phase function phase must be a function with the signature     phase(r1::AbstractVector, r2::AbstractVector)\n\nNote:\n\nthis should be the last step when constructing a tight-binding  Hamiltonian\nYou need to make sure that the phases that you add do not break translational symmetries. This is not a trivial matter and may lead to unexpected/undetected mistakes.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.peierlsinplane!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, AbstractVector}","page":"API Reference","title":"LatticeQM.Operators.peierlsinplane!","text":"peierls!(hops, lat, B)\n\nAdd Peierls phases to operator hops on lattice geometry lat for the uniform in-plane magnetic field B=(B1,B2). Uses in-plane gauge, see uniformfieldphase_inplane(...).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.peierlsoutplane-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Int64, Int64}","page":"API Reference","title":"LatticeQM.Operators.peierlsoutplane","text":"peierlsoutplane(hops, lat, p, q)\n\nAdd uniform out-of-plane magnetic field B=(0,0,B3) to operator hops on lattice geometry lat, such that the flux per unit cell is Φ=p/q.\n\nThis method automatically constructs and returns the correct superoperartor and magnetic supercell.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.setfilling!-Tuple{Any, Any, Any}","page":"API Reference","title":"LatticeQM.Operators.setfilling!","text":"setfilling!(H, kgrid::Structure.Mesh, filling; kwargs...)\n\nVariant that accepts an explicit k-grid kgrid (e.g., from regulargrid). Computes μ on that grid and shifts H in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.setfilling!-Tuple{Any, Any}","page":"API Reference","title":"LatticeQM.Operators.setfilling!","text":"setfilling!(H, filling; nk=100, kwargs...)\n\nShift the chemical potential of Hamiltonian-like object H so that the resulting electronic filling matches filling (0–1 per spin). Internally uses Spectrum.chemicalpotential on a regular nk × nk grid and then applies addchemicalpotential!(H, -μ).\n\nKeywords are forwarded to the underlying solver (e.g., temperature T, diagonalization format).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.superlattice-Tuple{Hops, Vector{Int64}, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Operators.superlattice","text":"superlattice(hops, periods)\n\nTurn a given hopping model into a superlattice model by copying cells and hoppings. This method can be useful as preparation before adding modulations that change the periodicity of the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.uniformfieldphase-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractVector)","page":"API Reference","title":"LatticeQM.Operators.uniformfieldphase","text":"uniformfieldphase(r1,r2; B)\n\nThe proper relative phase between lattice positions r1 and r2 in presence of magnetic field B=(B1,B2,...). Calculated in Coulomb gauge!\n\nThe magnetic field should be in units of flux quanta phi_0=he.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.uniformfieldphase_inplane-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractVector)","page":"API Reference","title":"LatticeQM.Operators.uniformfieldphase_inplane","text":"uniformfieldphase_inplane(r1,r2; B)\n\nThe proper relative phase between lattice positions r1 and r2 in presence of magnetic field B=(B1,B2,0). \n\nHere we use the gauge A = (B2 z, - B1 z, 0)\n\nThe magnetic field should be in units of flux quanta phi_0=he.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.uniformfieldphase_outplane-Tuple{LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Operators.uniformfieldphase_outplane","text":"uniformfieldphase_outplane(lat, Φ)\n\nPasses the lattice vectors a1 and a2 to uniformfieldphase_outplane(a1,a2,Φ).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.uniformfieldphase_outplane-Union{Tuple{T}, Tuple{T, T, Number}} where T<:(AbstractVector)","page":"API Reference","title":"LatticeQM.Operators.uniformfieldphase_outplane","text":"uniformfieldphase_outplane(a1,a2)\n\nThis returns the phase function that respects translational symmetry along a_1 but not along a_2. For rational flux Φ=p/q, this gauge is periodic in a2'=q*a2.\n\nThe magnetic field should be in units of flux quanta phi_0=he.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Operators.valley-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Operators.valley","text":"valley(lat; spinhalf=false, kwargs...)\n\nConstruct a valley operator on lat. If spinhalf=true, attach spin structure to match spinful Hamiltonians.\n\n\n\n\n\n","category":"method"},{"location":"api/#Spectrum","page":"API Reference","title":"Spectrum","text":"","category":"section"},{"location":"api/#LatticeQM.Spectrum.BandData","page":"API Reference","title":"LatticeQM.Spectrum.BandData","text":"BandData\n\nStruct to store BandData obtained from method getbands(...). The fields BandData.bands is a matrix of eigenvalues at each point along a path, the field BandData.obs is a matrix of expectation values and BandData.path is a DiscretePath object (contains discrete points and point labels).\n\nCan be saved conveniently with savedlm(bands; path=\"data\") and plotted with plot(bands).``\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeQM.Spectrum.bandmatrix-Tuple{Any, Any, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Spectrum.bandmatrix","text":"bandmatrix(H, ks::Matrix{Float} [, As]; kwargs...)\n\nCalculates the energies for operator H(k) for each column vector k of matrix ks. If operators As=[A1, A2, ...] are given, their expectaction values are calculated and stored for each eigenvector.\n\nAccepts the same keywords as geteigvals, geteigvecs, geteigen. In particular: format (:sparse or :dense) and num_bands::Int.\n\nReturns a matrix where each column contains the energies for each column k in ks. If As were given, a second matrix of the same format is returned containing expectation values.\n\nExample\n\nusing LatticeQM\n\nlat = Geometries.honeycomb()\nh = Operators.graphene(lat)\nks = kpath(lat; num_points=200)\nvalley = Operators.valleyoperator(lat)\n\nbands, obs = bandmatrix(h, ks.points, valley)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.berry","page":"API Reference","title":"LatticeQM.Spectrum.berry","text":"berry(H, NX::Int, NY::Int=0, bandindices::AbstractArray=[])\n\nConvenience method for berry(statesgrid).\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Spectrum.berry-Tuple{AbstractArray{<:Complex, 4}}","page":"API Reference","title":"LatticeQM.Spectrum.berry","text":"berry(statesgrid)\n\nGoes through each plaquette (i,j),(i+1,j),(i+1,j+1),(i,j+1) and calculates the (non-abelian) plaquette phase. statesgrid is a four-dimenional array, containing the discretization information and the occupied states.\n\nYou can create a statesgrid with statesgrid(H, nx, ny, bandindices) or use the wrapper berry(H, nx, ny, bandindices).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.berryalongpath-Tuple{Any, Any}","page":"API Reference","title":"LatticeQM.Spectrum.berryalongpath","text":"berryalongpath(H, kpoints)\n\nCalculate the abelian Berry curvature for each band along a path of discrete k points. It builds little plaquettes along the path between the kpoints[:,i] and kpoints[:,i+1].\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.fermisurfacedensity-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Spectrum.fermisurfacedensity","text":"fermisurfacedensity(H, energies; broadening=:auto, lat=nothing, num_points=15, kwargs...)\n\nHigh‑level convenience that computes band energies on a regular k‑grid and then returns (kgrid, density) as produced by fermisurfacedensity_fromdata. If lat is provided, the grid is folded into the first Brillouin zone and mapped to Cartesian reciprocal space via getB(lat).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.fermisurfacedensity_fromdata-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}","page":"API Reference","title":"LatticeQM.Spectrum.fermisurfacedensity_fromdata","text":"fermisurfacedensity_fromdata(bands, energies, obs; broadening=:auto)\n\nWeighted variant where obs provides an observable per band and k‑point of the same shape as bands. Each Lorentzian contribution is multiplied by the corresponding weight.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.fermisurfacedensity_fromdata-Tuple{AbstractMatrix, AbstractVector}","page":"API Reference","title":"LatticeQM.Spectrum.fermisurfacedensity_fromdata","text":"fermisurfacedensity_fromdata(bands, energies; broadening=:auto)\n\nBroadened Fermi‑surface density without weights/observables. See fermisurfacedensity_fromdata(bands, energy; ...) for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.fermisurfacedensity_fromdata-Tuple{Any, Number, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Spectrum.fermisurfacedensity_fromdata","text":"fermisurfacedensity_fromdata(bands, energy; broadening=:auto)\n\nCompute a broadened Fermi‑surface “density” from a band‑energy matrix bands of size (nbands, Nk) evaluated on a k‑grid. energy can be a scalar or a vector of Fermi energies. The result has size (length(energies), Nk) and sums contributions from all bands using a Lorentzian of width broadening.\n\nIf broadening == :auto (default), a heuristic width based on the band dispersion is used.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.getbands-Tuple{Any, Any, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Spectrum.getbands","text":"getbands(H, ks::Union{DiscretePath, AbstractMatrix} [, As]; kwargs...)\n\nCalculates the bands for operator H along discrete path ks and if operators As=[A1, A2, ...] are given, their expectaction values are calculated and stored for each eigenvector.\n\nNote that ks is a discrete path object as returned by kpath(lat::Lattice,...).\n\nAccepts the same keywords as geteigvals, geteigvecs, geteigen. In particular: format (:sparse or :dense) and num_bands::Int.\n\nReturns a BandData object (with fields bands, obs, path).\n\nExample\n\nusing LatticeQM\n\nlat = Geometries.honeycomb()\nh = Operators.graphene(lat)\nks = kpath(lat; num_points=200)\nvalley = Operators.valleyoperator(lat)\n\nbands = getbands(h, ks, valley)\n\nusing Plots\nplot(bands)\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.getberry!-Tuple{LatticeQM.Spectrum.BandData, Any, Any}","page":"API Reference","title":"LatticeQM.Spectrum.getberry!","text":"getberry!(bands, h, ks)\n\nCalculates and appends the data from berryalongpath(h,ks) to the data object bands. This is a convenience method that is useful when plotting band diagrams with Berry curvatures colored it.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.getbroadening-Tuple{Any, Any}","page":"API Reference","title":"LatticeQM.Spectrum.getbroadening","text":"getbroadening(broadening, bands)\n\nInternal helper that resolves broadening to a numeric value. For :auto, uses the mean band standard deviation divided by √Nk.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.getcherns","page":"API Reference","title":"LatticeQM.Spectrum.getcherns","text":"getcherns(wavefunctions::Function, NX::Int, NY::Int=0, bands::AbstractArray=[])\n\nReturns the chern numbers of wavefunctions corresponding to all bands in bands, where NX and NY denote the coarseness of discretization of k-space. For bands=[] it returns all chern numbers.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Spectrum.getdos","page":"API Reference","title":"LatticeQM.Spectrum.getdos","text":"getdos(h, emin::Float64, emax::Float64, num=500; kwargs...)\n\nComputes the density of states of operator h(k) on the entire Brillouine zone, discretized on a grid with $ k{lin} \\times k{lin} $ points.  and for the frequencies ωs=(ωmin, ω2, ..., ωmax). The paremter Gamma is the energy broadening.\n\nAccepts the same kwargs as getdos(h, ωs; klin, Γ, kwargs...).\n\nNote: the current implementation only works for a two-dimensional Brillouine zone. Might change in the future, but for now use dos(h, ks, ω; Γ) syntax if needed.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Spectrum.getdos-Tuple{Any, AbstractVector, Any, Vararg{Any}}","page":"API Reference","title":"LatticeQM.Spectrum.getdos","text":"getdos(h, ks, ω; Γ, parallel=true, format=:auto)\n\nComputes the density of states of operator h(k) using the points ks=(k1,k2,...) and for the frequencies ω=(ω1, ω2, ...). The paremter Gamma is the energy broadening.\n\nMode can be :distributed or :serial, format can be :auto, :sparse or :dense.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.getdos-Tuple{Any, Any}","page":"API Reference","title":"LatticeQM.Spectrum.getdos","text":"getdos(h, ωs; klin, Γ, kwargs...)\n\nComputes the density of states of operator h(k) on the entire Brillouine zone, discretized on a grid with $ k{lin} \\times k{lin} $ points.  and for the frequencies ωs=(ω1, ω2, ...). The paremter Gamma is the energy broadening.\n\nAccepts the same kwargs as dos(h, ks, ω).\n\nNote: the current implementation only works for a two-dimensional Brillouine zone. Might change in the future, but for now use dos(h, ks, ω; Γ) syntax if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.getwindnum","page":"API Reference","title":"LatticeQM.Spectrum.getwindnum","text":"getwindnum(wavefunctions::Function, NX::Int, NY::Int=0, bandnr::Integer=1)\n\nReturns the winding number (according to Rudner et al. 2013) of the band which is on position bandnr in the spectrum. NX and NY denote the coarsness of the discretization in k-space and wavefunctions is a function returning the wavefunctions of the problem. (NB: The winding number of a band is the sum of the chern numbers of all the bands below it including its own chern number. For undriven systems or systems which are driven but \"normal\" it is equal to the chern number of said band. It only makes sense when looking at Floquet bands ie quasi-energies.)\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Spectrum.plaquettephase-Union{Tuple{T}, Tuple{N}, NTuple{4, T}} where {N, T<:(AbstractArray{<:Complex, N})}","page":"API Reference","title":"LatticeQM.Spectrum.plaquettephase","text":"plaquettephase(S00, S10, S01, S11)\n\nCalculates the phase the (non-abelian) phase winding around a plaquette.\n\nThis method is not meant to be called directly, it is used by berry(statesgrid).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Spectrum.statesgrid","page":"API Reference","title":"LatticeQM.Spectrum.statesgrid","text":"statesgrid(H, NX::Int, NY::Int=0, bandindices::AbstractArray=[])\n\nEvaluates the eigenvectors on a discretized grid (2D Hamiltonian only!) and stores the result (preserving the grid information). This method is useful when plaquette phases need to be calculated.\n\nNote thate statesgrid[i,j,:,k] is the k-th eigenvector at gridpoint i,j.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearResponse","page":"API Reference","title":"LinearResponse","text":"","category":"section"},{"location":"api/#LatticeQM.LinearResponse.opticalconductivity-Tuple{AbstractVector, Any, Any, Any, AbstractMatrix}","page":"API Reference","title":"LatticeQM.LinearResponse.opticalconductivity","text":"opticalconductivity(frequencies, H, J1, J2, ks; μ=0.0, Γ=0.025, T=0.1, ...)\n\nEvaluate the Kubo formula for the optical conductivity tensor at the set of frequencies and k‑points ks (columns). H, J1, and J2 are callable with a k‑vector and return the Hamiltonian and current operators, respectively.\n\nReturns a complex vector σ(ω) normalized by the number of k‑points. μ is the chemical potential, Γ the phenomenological broadening and T the temperature (all in the same energy units as H). Additional keyword arguments are forwarded to the eigenvalue solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.LinearResponse.opticalconductivity-Tuple{AbstractVector, Any, Any, Any}","page":"API Reference","title":"LatticeQM.LinearResponse.opticalconductivity","text":"opticalconductivity(frequencies, H, J1, J2; klin, kwargs...)\n\nCompute σ(ω) on a regular klin × klin k‑grid using currents J1, J2. Convenience front‑end to the explicit‑grid method.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.LinearResponse.opticalconductivity-Tuple{AbstractVector, Int64, Int64, Any, LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}","page":"API Reference","title":"LatticeQM.LinearResponse.opticalconductivity","text":"opticalconductivity(frequencies, i, j, H, lat; kwargs...)\n\nCompute σ_ij(ω) for Hamiltonian H(k) using the Cartesian components i, j of the current operator defined on lat. Internally obtains J = getcurrentoperators(lat, H) and forwards to the low‑level routine.\n\nCommon keywords: μ (chemical potential), Γ (broadening), T (temperature), plus diagonalization options forwarded to the eigen solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.LinearResponse.opticalconductivityXX-Tuple{AbstractVector, Any, LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}","page":"API Reference","title":"LatticeQM.LinearResponse.opticalconductivityXX","text":"opticalconductivityXX(frequencies, H, lat; kwargs...)\n\nConvenience wrapper computing σ_xx(ω) via the Kubo formula. Builds current operators from H and lat and evaluates at the provided frequencies.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.LinearResponse.opticalconductivityXY-Tuple{AbstractVector, Any, LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}","page":"API Reference","title":"LatticeQM.LinearResponse.opticalconductivityXY","text":"opticalconductivityXY(frequencies, H, lat; kwargs...)\n\nConvenience wrapper computing σ_xy(ω). See opticalconductivity(frequencies, i, j, H, lat; ...) for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Meanfield","page":"API Reference","title":"Meanfield","text":"","category":"section"},{"location":"api/#LatticeQM.Meanfield.HartreeFock","page":"API Reference","title":"LatticeQM.Meanfield.HartreeFock","text":"HartreeFock(h, v, μ=0.0; hartree=true, fock=true)\n\nMean‑field functional for density (Hartree) and exchange (Fock) channels built from a base Hamiltonian h and interaction kernels v. Calling the struct on ρ updates the effective mean‑field operator hMF and scalar energy ϵMF.\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeQM.Meanfield.MeanfieldGenerator","page":"API Reference","title":"LatticeQM.Meanfield.MeanfieldGenerator","text":"MeanfieldGenerator\n\nAbstract supertype for mean‑field functionals that map a density matrix ρ to an effective single‑particle Hamiltonian and scalar energy contributions. Concrete implementations include HartreeFock and HartreeFockBDG.\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeQM.Meanfield.fixedpoint!-Tuple{Any, Any, Any}","page":"API Reference","title":"LatticeQM.Meanfield.fixedpoint!","text":"fixedpoint!(f!, x1, x0; iterations=500, tol=1e-7, β=1.0, p_norm::Real=2, show_trace=false, clear_trace=false)\n\nPerforms a simple fixed point iteration. The function f!(x1,x0) should override with x1 with x2 and x0 with x1 and can optionally return a scalar value (for example ground state energy at iteration step). \n\nFixedpoint iteration, tested on the square-root example f_a(x) = 1/2 * (a/x+x) which has the fixed point x0 = sqrt(a).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Meanfield.mapspindensitymatrix-Tuple{AbstractVector}","page":"API Reference","title":"LatticeQM.Meanfield.mapspindensitymatrix","text":"mapspindensitymatrix(vs::AbstractVector, Is::AbstractVector{Int}, N::Int) --> SparseMatrix{Complex}\nmapspindensitymatrix(vs::AbstractVector, Is::AbstractVector{Int}) = mapspindensitymatrix(vs, Is, length(Is)) --> SparseMatrix{Complex}\nmapspindensitymatrix(vs::AbstractVector) --> SparseMatrix{Complex}\n\nFrom a list of spin orientations vs (and optionally lattice indices Is, and optionally total number of lattice sites N), a spin density matrix for multiple lattice sites is generated.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Meanfield.solvehartreefock-Union{Tuple{T}, Tuple{T, Any, Any, Number, Vararg{Any}}} where T","page":"API Reference","title":"LatticeQM.Meanfield.solvehartreefock","text":"solvehartreefock(h, v, ρ_init, filling; kwargs...)\n\nConvenience wrapper around solveselfconsistent that constructs a HartreeFock functional from base Hamiltonian h and interaction kernel v. Returns the converged mean‑field solution and metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Meanfield.solveselfconsistent!-Union{Tuple{T1}, Tuple{LatticeQM.Utils.Context.DummyContext, T1, T1, LatticeQM.Meanfield.MeanfieldGenerator, Float64, Any}} where T1","page":"API Reference","title":"LatticeQM.Meanfield.solveselfconsistent!","text":"solveselfconsistent!(ρ0, ρ1, ℋ_op, ℋ_scalar, filling, ks; convergenceerror=false, multimode=:serial, checkpoint::String=\"\", hotstart=true, iterations=500, tol=1e-7, T=0.0, format=:dense, verbose::Bool=false, kwargs...)\nsolveselfconsistent!(ρ0, ℋ_op, ℋ_scalar, filling, ks; kwargs...)\nsolveselfconsistent!(ρ0, ρ1, ℋ_op, ℋ_scalar, filling; klin, kwargs...)\nsolveselfconsistent!(ρ0, ℋ_op, ℋ_scalar, filling; klin, kwargs...)\n\nSearches a self-consistent meanfield solution for the functional ℋ: ρ → h at given filling (between 0 and 1). k space is discretized with the given points ks. returns (1) the density matrix of the meanfield (2) ground state energy of the meanfield operator (3) the chemical potential (4) convergence flag (bool) (5) error estimate\n\nIf the checkpoint keyword is set, e.g. checkpoint=\"mf.jld\", the mean field will be saved into a file at each step of the iteration, allowing to interrupt and restart a long-running calculation safely. If checkpoint is set and the file exists, this method will assume that the file contains a valid mean-field and use it as initial guess. To avoid this behavior, specify hotstart=false.\n\nparallel=true might help if diagonalization per k point is very time consuming (e.g. for twisted bilayer graphene) note that for small problems parallel=true may decrease performance (communication overhead)\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Meanfield.solveselfconsistent-Tuple{Any, LatticeQM.Meanfield.MeanfieldGenerator, Number, Any}","page":"API Reference","title":"LatticeQM.Meanfield.solveselfconsistent","text":"solveselfconsistent(ρ0, mf::MeanfieldGenerator, filling, ks; kwargs...)\nsolveselfconsistent(ρ0, mf::MeanfieldGenerator, filling; klin, kwargs...)\n\nNon‑mutating convenience wrappers around [solveselfconsistent!] that copy the initial density matrix ρ0, iterate the mean‑field functional mf (e.g., HartreeFock), and return the converged result together with energy and state.\n\nThe filling sets the target electronic filling (0–1 per spin). Supply either an explicit k‑grid ks or a grid resolution via klin (uses klin×klin).\n\nCommon keywords: iterations, tol, T, β (mixing), multimode (parallel).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Meanfield.solveselfconsistent_purification!-Union{Tuple{T1}, Tuple{LatticeQM.Utils.Context.DummyContext, T1, T1, LatticeQM.Meanfield.MeanfieldGenerator, Float64, Any}} where T1","page":"API Reference","title":"LatticeQM.Meanfield.solveselfconsistent_purification!","text":"solveselfconsistent!(ρ0, ρ1, ℋ_op, ℋ_scalar, filling, ks; convergenceerror=false, multimode=:serial, checkpoint::String=\"\", hotstart=true, iterations=500, tol=1e-7, T=0.0, format=:dense, verbose::Bool=false, kwargs...)\nsolveselfconsistent!(ρ0, ℋ_op, ℋ_scalar, filling, ks; kwargs...)\nsolveselfconsistent!(ρ0, ρ1, ℋ_op, ℋ_scalar, filling; klin, kwargs...)\nsolveselfconsistent!(ρ0, ℋ_op, ℋ_scalar, filling; klin, kwargs...)\n\nSearches a self-consistent meanfield solution for the functional ℋ: ρ → h at given filling (between 0 and 1). k space is discretized with the given points ks. returns (1) the density matrix of the meanfield (2) ground state energy of the meanfield operator (3) the chemical potential (4) convergence flag (bool) (5) error estimate\n\nIf the checkpoint keyword is set, e.g. checkpoint=\"mf.jld\", the mean field will be saved into a file at each step of the iteration, allowing to interrupt and restart a long-running calculation safely. If checkpoint is set and the file exists, this method will assume that the file contains a valid mean-field and use it as initial guess. To avoid this behavior, specify hotstart=false.\n\nparallel=true might help if diagonalization per k point is very time consuming (e.g. for twisted bilayer graphene) note that for small problems parallel=true may decrease performance (communication overhead)\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Meanfield.spindensitymatrix","page":"API Reference","title":"LatticeQM.Meanfield.spindensitymatrix","text":"spindensitymatrix(d::Vector=[1,0,0]) --> Matrix{Float64}\nspindensitymatrix(x::Real=1) --> Matrix{Float64}\nspindensitymatrix(s::Symbol) --> Matrix{Float64}\n\nReturns a spin-1/2 density matrix for given spin orientiation d=[dx,dy,dz]. Instead, one can also specify the configuration symbolically, in which case s should be one of :up,:down,:upx,:downx,:upy,:downy.\n\nIf vector has norm larger one it gets normalized, otherwise it is left unscaled.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Meanfield.spinspiraldensitymatrix-Tuple{LatticeQM.Structure.Lattices.Lattice, Any}","page":"API Reference","title":"LatticeQM.Meanfield.spinspiraldensitymatrix","text":"spinspiraldensitymatrix(lat::Lattice, superperiods; n::Vector=[0,0,1], v0::Vector=[1,0,0])\n\nCreate a spin spiral density matrix with periodicity given by a superlattice characterized by superperiods' (see Structure.superlattice for details). The rotation goes around the fixed axisn=[n1,n2,n3]. The vectorv0` specifies the spin direction in one site.\n\nUseful to create initial states for mean field calculations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Superconductivity","page":"API Reference","title":"Superconductivity","text":"","category":"section"},{"location":"api/#LatticeQM.Superconductivity.BdGOperator","page":"API Reference","title":"LatticeQM.Superconductivity.BdGOperator","text":"BdGOperator(h::Hops)\nBdGOperator(h::Hops, Δ::Hops)\n\nBogoliubov–de Gennes operator wrapper that lifts a normal‑state hopping object h to Nambu space and optionally adds a pairing block Δ. The resulting operator behaves like a Hamiltonian H(k) and can be passed to spectrum and mean‑field routines.\n\nRelated helpers:\n\naddpairing!(H::BdGOperator, Δ) — insert/update the pairing block.\naddelectronsector!(H::BdGOperator, h) — add to the electron block.\ngetelectionview/getpairingview — views into electron/pairing sectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Floquet","page":"API Reference","title":"Floquet","text":"","category":"section"},{"location":"api/#LatticeQM.Floquet.periodicDrive","page":"API Reference","title":"LatticeQM.Floquet.periodicDrive","text":"periodicDrive(omega::Number=1)\n\nReturn an empty periodic drive with frequency omega.\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeQM.Floquet.periodicDrive-2","page":"API Reference","title":"LatticeQM.Floquet.periodicDrive","text":"mutable struct periodicDrive\n\nType representing a time-periodic potential applied to a lattice. Contains the fields:  \n\nomega: Frequency of the potential.  \noperators: An array of operators (Matrices) representing the Fourier components of the potential.  \nns: An array of integers containing the modes which are not zero. (Should not contain 0)    This implies that operators and ns must have the same length and must be ordered such that    operators[i] corresponds to the ns[i] fourier component for all i.\n\nExample:       The following returns a drive corresponding to a periodic potentisl V(t):       V(t) = [0 1; -1 0]exp(-im2.5t) + [0 -1; 1 0]exp(3im2.5*t)\n\ndrive = periodicDrive(2.5, [[0 1; -1 0], [0 -1; 1 0]], [-1,3])\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeQM.Floquet.periodicDrive-Tuple{Number, AbstractVector{Number}, AbstractMatrix{Number}}","page":"API Reference","title":"LatticeQM.Floquet.periodicDrive","text":"periodicDrive(omega::Number, funcFourier::AbstractArray{Number, 1}, operator::AbstractMatrix{Number})\n\nAllows for initializing a periodicDrive using only one operator and Fourier components of a periodic function denoting the amplitude (over time) with which the operator is applied.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Floquet.addFreq!-Tuple{LatticeQM.Floquet.periodicDrive, AbstractMatrix, Integer}","page":"API Reference","title":"LatticeQM.Floquet.addFreq!","text":"addFreq!(drive::periodicDrive, operator::AbstractMatrix, n::Integer)\n\nAdd a single harmonic mode to an existing periodicDrive.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Floquet.addcos!-Tuple{LatticeQM.Floquet.periodicDrive, AbstractMatrix, Integer}","page":"API Reference","title":"LatticeQM.Floquet.addcos!","text":"addcos!(drive::periodicDrive, operator::AbstractMatrix, n::Integer)\n\nAdd the operator applied with a cosine of frequency n*omega to an existing periodicDrive.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Floquet.getFloquetMatrix-Tuple{Integer, AbstractMatrix, LatticeQM.Floquet.periodicDrive}","page":"API Reference","title":"LatticeQM.Floquet.getFloquetMatrix","text":"getFloquetMatrix(M::Integer, H0::AbstractMatrix, drive::periodicDrive; hbar::Number=1.)\n\nBuild the effective Hamiltonian for several harmonic driving modes, i.e., V(t) = sum_j V_j exp(i*j*n_j*omega).\n\nM: truncation   H0: time averaged Hamiltonian (i.e., has already absorbed the constant m=0 mode), must be matrix drive: periodicDrive object\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Floquet.getfirstFBZ-Tuple{AbstractArray, Integer}","page":"API Reference","title":"LatticeQM.Floquet.getfirstFBZ","text":"function reducetoFBZ(bands::AbstractArray, M::Integer) Takes a two dimensional array denoting a list of bands which came from diagonalizing a Floquet Hamiltonian and returns the bands lying in the first Floquet Brioullin zone.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Floquet.keepfirstFBZ!-Tuple{LatticeQM.Spectrum.BandData, LatticeQM.Floquet.FloquetOperator}","page":"API Reference","title":"LatticeQM.Floquet.keepfirstFBZ!","text":"keepfirstFBZ!(data::Spectrum.BandData, H::FloquetOperator)\n\nThrow away all band data except for the first Floquet Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Floquet.transform-Tuple{Vector{ComplexF64}, Integer, Integer, Number}","page":"API Reference","title":"LatticeQM.Floquet.transform","text":"Converts an eigenvector vec obtained from solving the infinite (truncated at M) Floquet problem to an eigenvector in time space (at time t).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Floquet.transformeigvecs-Tuple{AbstractMatrix, Integer, Number}","page":"API Reference","title":"LatticeQM.Floquet.transformeigvecs","text":"transformeigvecs(U::AbstractMatrix, M::Integer, t::Number) Converts a matrix of eigenvectors U obtained from solving the infinite (truncated at M) Floquet problem to eigenvectors in time space (at time t).\n\n\n\n\n\n","category":"method"},{"location":"api/#Plotting","page":"API Reference","title":"Plotting","text":"","category":"section"},{"location":"api/#Utils","page":"API Reference","title":"Utils","text":"","category":"section"},{"location":"api/#LatticeQM.Utils.padvec-Tuple{AbstractVector, Int64}","page":"API Reference","title":"LatticeQM.Utils.padvec","text":"padvec(v::AbstractVector, d::Int)\n\nMake sure Vector v has length d, pad with zeros if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeQM.Utils.spinorrotation","page":"API Reference","title":"LatticeQM.Utils.spinorrotation","text":"spinorrotation(θ, n=[0,0,1])\n\nReturns SU(2) spinor rotation matrix U parametrized by rotation angle θ and rotation axis n=[n1,n2,n3]. U = exp(-i (θ/2) σ.n).\n\nNote: This routine will always normalize n.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Utils.@scalar2vector","page":"API Reference","title":"LatticeQM.Utils.@scalar2vector","text":"scalar2vector(f0, N=3)\n\nThis is macro is a wrapper that takes as input a function f0(x::Float64) and adds a new dispatch f0(r1::Vector, r2::Vector) = f0(norm(r1-r2)) while making sure that r1 and r2 do not exceed length N.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Common-Entrypoints","page":"API Reference","title":"Common Entrypoints","text":"","category":"section"},{"location":"api/#LatticeQM.Spectrum.getbands","page":"API Reference","title":"LatticeQM.Spectrum.getbands","text":"getbands(H, ks::Union{DiscretePath, AbstractMatrix} [, As]; kwargs...)\n\nCalculates the bands for operator H along discrete path ks and if operators As=[A1, A2, ...] are given, their expectaction values are calculated and stored for each eigenvector.\n\nNote that ks is a discrete path object as returned by kpath(lat::Lattice,...).\n\nAccepts the same keywords as geteigvals, geteigvecs, geteigen. In particular: format (:sparse or :dense) and num_bands::Int.\n\nReturns a BandData object (with fields bands, obs, path).\n\nExample\n\nusing LatticeQM\n\nlat = Geometries.honeycomb()\nh = Operators.graphene(lat)\nks = kpath(lat; num_points=200)\nvalley = Operators.valleyoperator(lat)\n\nbands = getbands(h, ks, valley)\n\nusing Plots\nplot(bands)\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Spectrum.getdos-2","page":"API Reference","title":"LatticeQM.Spectrum.getdos","text":"getdos(h, emin::Float64, emax::Float64, num=500; kwargs...)\n\nComputes the density of states of operator h(k) on the entire Brillouine zone, discretized on a grid with $ k{lin} \\times k{lin} $ points.  and for the frequencies ωs=(ωmin, ω2, ..., ωmax). The paremter Gamma is the energy broadening.\n\nAccepts the same kwargs as getdos(h, ωs; klin, Γ, kwargs...).\n\nNote: the current implementation only works for a two-dimensional Brillouine zone. Might change in the future, but for now use dos(h, ks, ω; Γ) syntax if needed.\n\n\n\n\n\ngetdos(h, ωs; klin, Γ, kwargs...)\n\nComputes the density of states of operator h(k) on the entire Brillouine zone, discretized on a grid with $ k{lin} \\times k{lin} $ points.  and for the frequencies ωs=(ω1, ω2, ...). The paremter Gamma is the energy broadening.\n\nAccepts the same kwargs as dos(h, ks, ω).\n\nNote: the current implementation only works for a two-dimensional Brillouine zone. Might change in the future, but for now use dos(h, ks, ω; Γ) syntax if needed.\n\n\n\n\n\ngetdos(h, ks, ω; Γ, parallel=true, format=:auto)\n\nComputes the density of states of operator h(k) using the points ks=(k1,k2,...) and for the frequencies ω=(ω1, ω2, ...). The paremter Gamma is the energy broadening.\n\nMode can be :distributed or :serial, format can be :auto, :sparse or :dense.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.LinearResponse.opticalconductivity","page":"API Reference","title":"LatticeQM.LinearResponse.opticalconductivity","text":"opticalconductivity(frequencies, i, j, H, lat; kwargs...)\n\nCompute σ_ij(ω) for Hamiltonian H(k) using the Cartesian components i, j of the current operator defined on lat. Internally obtains J = getcurrentoperators(lat, H) and forwards to the low‑level routine.\n\nCommon keywords: μ (chemical potential), Γ (broadening), T (temperature), plus diagonalization options forwarded to the eigen solver.\n\n\n\n\n\nopticalconductivity(frequencies, H, J1, J2; klin, kwargs...)\n\nCompute σ(ω) on a regular klin × klin k‑grid using currents J1, J2. Convenience front‑end to the explicit‑grid method.\n\n\n\n\n\nopticalconductivity(frequencies, H, J1, J2, ks; μ=0.0, Γ=0.025, T=0.1, ...)\n\nEvaluate the Kubo formula for the optical conductivity tensor at the set of frequencies and k‑points ks (columns). H, J1, and J2 are callable with a k‑vector and return the Hamiltonian and current operators, respectively.\n\nReturns a complex vector σ(ω) normalized by the number of k‑points. μ is the chemical potential, Γ the phenomenological broadening and T the temperature (all in the same energy units as H). Additional keyword arguments are forwarded to the eigenvalue solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Meanfield.solvehartreefock","page":"API Reference","title":"LatticeQM.Meanfield.solvehartreefock","text":"solvehartreefock(h, v, ρ_init, filling; kwargs...)\n\nConvenience wrapper around solveselfconsistent that constructs a HartreeFock functional from base Hamiltonian h and interaction kernel v. Returns the converged mean‑field solution and metadata.\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Meanfield.solveselfconsistent","page":"API Reference","title":"LatticeQM.Meanfield.solveselfconsistent","text":"solveselfconsistent(ρ0, mf::MeanfieldGenerator, filling, ks; kwargs...)\nsolveselfconsistent(ρ0, mf::MeanfieldGenerator, filling; klin, kwargs...)\n\nNon‑mutating convenience wrappers around [solveselfconsistent!] that copy the initial density matrix ρ0, iterate the mean‑field functional mf (e.g., HartreeFock), and return the converged result together with energy and state.\n\nThe filling sets the target electronic filling (0–1 per spin). Supply either an explicit k‑grid ks or a grid resolution via klin (uses klin×klin).\n\nCommon keywords: iterations, tol, T, β (mixing), multimode (parallel).\n\n\n\n\n\n","category":"function"},{"location":"api/#LatticeQM.Operators.setfilling!","page":"API Reference","title":"LatticeQM.Operators.setfilling!","text":"setfilling!(H, filling; nk=100, kwargs...)\n\nShift the chemical potential of Hamiltonian-like object H so that the resulting electronic filling matches filling (0–1 per spin). Internally uses Spectrum.chemicalpotential on a regular nk × nk grid and then applies addchemicalpotential!(H, -μ).\n\nKeywords are forwarded to the underlying solver (e.g., temperature T, diagonalization format).\n\n\n\n\n\nsetfilling!(H, kgrid::Structure.Mesh, filling; kwargs...)\n\nVariant that accepts an explicit k-grid kgrid (e.g., from regulargrid). Computes μ on that grid and shifts H in place.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/twisted_bilayers/#Tutorial-4-—-Twisted-Bilayer-Graphene","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4 — Twisted Bilayer Graphene","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"Primary notebook: extra/tutorial/Tutorial4_Twisted.ipynb   Experimental variants: Tutorial4_Twisted2.ipynb, Tutorial4_Twisted3.ipynb","category":"page"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"This tutorial family covers moiré superlattices and the resource-saving tricks needed to handle large twisted bilayer graphene (TBG) systems. The main notebook focuses on a validated workflow, while the follow-up variants capture ongoing experiments—treat them as provisional until you reproduce the outputs.","category":"page"},{"location":"tutorials/twisted_bilayers/#Learning-goals","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Learning goals","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"Construct twisted honeycomb geometries with Geometries.honeycomb_twisted(θ_steps).\nAssemble continuum-inspired tight-binding models tuned for small twist angles.\nBalance accuracy and runtime by adjusting reciprocal cutoffs, symmetry reductions, and sparse/dense representations.\nPost-process bandstructures and real-space density profiles for moiré cells.","category":"page"},{"location":"tutorials/twisted_bilayers/#Prerequisites","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"Comfort with Tutorials 1–3.\nAccess to sufficient RAM/CPU; large twist indices can require several GB.","category":"page"},{"location":"tutorials/twisted_bilayers/#Workflow-outline","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Workflow outline","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"Geometry generation — Pick a twist index (e.g. θ = 21) and generate bilayer lattices with precise stacking.\nHamiltonian strategy — Decide between tight-binding truncation and continuum approximations; the notebook demonstrates both.\nSymmetry reduction — Use point-group symmetries and Brillouin-zone sampling strategies to limit the matrix dimension.\nBand computation — Leverage Spectrum.getbands with sparse matrices or switch to iterative solvers when dense diagonalisation is infeasible.\nObservables — Inspect layer and valley content with custom operators; export data for SCF refinement or visualisation.","category":"page"},{"location":"tutorials/twisted_bilayers/#Live-example","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Live example","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"figdir = joinpath(pwd(), \"figures\")\nmkpath(figdir)\nprintln(\"Output figures stored in \", figdir)","category":"page"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"println(\"Number of sites in mini Brillouin zone = \", size(positions, 2))\nprintln(\"Twist lattice vectors:\")\nStructure.Lattices.getA(lat_twisted)","category":"page"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"mask_pos = positions[3, :] .>= 0\nmask_neg = .!mask_pos\np = plot(size=(440, 380), aspect_ratio=1, xlabel=\"x (a)\", ylabel=\"y (a)\", legend=false, title=\"Twisted bilayer moiré cell (N=6)\")\nscatter!(positions[1, mask_pos], positions[2, mask_pos]; ms=3.0, markerstrokewidth=0, color=:royalblue)\nscatter!(positions[1, mask_neg], positions[2, mask_neg]; ms=3.0, markerstrokewidth=0, color=:tomato)\nsavefig(p, joinpath(figdir, \"tbg_positions.svg\"))\nnothing","category":"page"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"(Image: )","category":"page"},{"location":"tutorials/twisted_bilayers/#Band-structure-(N5)","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Band structure (N=5)","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"lat5 = Geometries.honeycomb_twisted(5, 1.0, 3.0)\nH5 = Operators.graphene(lat5; format=:sparse, cellrange=2)\nks5 = Structure.kpath(lat5; num_points=140)\nb5 = Spectrum.getbands(H5, ks5; format=:sparse, num_bands=40)\np_bands = plot(b5; size=(520, 360), title=\"TBG bands (N=5)\")\nsavefig(p_bands, joinpath(figdir, \"tbg_bands_N5.svg\"))\nnothing","category":"page"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"(Image: )","category":"page"},{"location":"tutorials/twisted_bilayers/#Validation-checklist","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Validation checklist","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"Reproduce low-energy flat bands around the magic angle used in the notebook.\nMonitor memory usage; if it spikes unexpectedly, confirm sparse conversions are applied (SparseHops or DenseHops as appropriate).\nArchive resulting figures and data files under extra/tutorial/output/tbg/ (or similar) for comparison across reruns.","category":"page"},{"location":"tutorials/twisted_bilayers/#Common-pitfalls","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Common pitfalls","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"Large twist indices explode the matrix size. Start with smaller N and increase gradually, using format=:sparse and limiting num_bands.\nEnsure the k-path is defined for the reduced Brillouin zone of the moiré lattice; mismatches cause misleading band plots.","category":"page"},{"location":"tutorials/twisted_bilayers/#Handling-experimental-notebooks-(Tutorial4_Twisted2/3)","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Handling experimental notebooks (Tutorial4_Twisted2/3)","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"Expect partially completed code paths; read cell notes carefully.\nWhen results differ from baseline expectations, note findings in your project tracker and decide whether to promote changes into the main tutorial.\nPromote stable improvements back into Tutorial4_Twisted.ipynb once validated, then retire the experimental copy.","category":"page"},{"location":"tutorials/twisted_bilayers/#Suggested-extensions","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Suggested extensions","text":"","category":"section"},{"location":"tutorials/twisted_bilayers/","page":"Tutorial 4: Twisted Bilayer Graphene","title":"Tutorial 4: Twisted Bilayer Graphene","text":"Couple the workflow to the twistedgraphene_scf example for mean-field studies.\nPrepare SLURM job scripts using the templates in extra/examples/twistedgraphene_slurm.\nCompare to Meanfield observables to investigate superconducting phases.","category":"page"},{"location":"tutorials/hofstadter/#Tutorial-5-—-Hofstadter-Butterfly","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5 — Hofstadter Butterfly","text":"","category":"section"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"Notebook: extra/tutorial/Tutorial5_Hofstadter.ipynb","category":"page"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"Study electrons on lattices subjected to uniform magnetic flux and observe the fractal Hofstadter spectrum.","category":"page"},{"location":"tutorials/hofstadter/#Learning-goals","page":"Tutorial 5: Hofstadter Butterfly","title":"Learning goals","text":"","category":"section"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"Thread magnetic flux through lattice models via Peierls phases or flux attachment helpers.\nSample dense momentum grids needed to resolve butterfly structures.\nGenerate high-resolution spectral plots and density-of-states traces.\nExplore parameter sweeps (flux, onsite energies) to map fine structure.","category":"page"},{"location":"tutorials/hofstadter/#Prerequisites","page":"Tutorial 5: Hofstadter Butterfly","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"Tutorials 1–2 (lattice construction and band plotting).\nPatience for longer runs—dense k-meshes can take minutes to hours depending on resolution.","category":"page"},{"location":"tutorials/hofstadter/#Workflow-outline","page":"Tutorial 5: Hofstadter Butterfly","title":"Workflow outline","text":"","category":"section"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"Flux insertion — Employ helper routines to add phase factors to hopping terms (see Operators utilities within the notebook).\nSampling strategy — Choose grid sizes (klin, kperp, etc.) and tolerances; consider batching to avoid memory spikes.\nSpectrum calculation — Use Spectrum.getbands or custom sparse solvers to compute eigenvalues across flux values.\nVisualisation — Plot energy vs. flux butterflies, optionally overlaying integrated density-of-states or gap labelling.\nData export — Store arrays for later inspection; the notebook saves .h5/.jld2 files for in-depth analysis.","category":"page"},{"location":"tutorials/hofstadter/#Live-example","page":"Tutorial 5: Hofstadter Butterfly","title":"Live example","text":"","category":"section"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"figdir = joinpath(pwd(), \"figures\")\nmkpath(figdir)\nnothing","category":"page"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"ϕs, dos = Operators.hofstadter_dos(\n    hops,\n    lat,\n    16,\n    collect(energies);\n    klin=36,\n    Γ=0.04\n)\nprintln(\"Density of states grid size = \", size(dos))\nnothing","category":"page"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"p = heatmap(\n    ϕs,\n    energies,\n    dos;\n    xlabel=\"Flux (ϕ/ϕ₀)\",\n    ylabel=\"Energy / t\",\n    colorbar_title=\"DOS\",\n    size=(380, 300)\n)\nsavefig(p, joinpath(figdir, \"hofstadter_dos.svg\"))\nnothing","category":"page"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"(Image: )","category":"page"},{"location":"tutorials/hofstadter/#Γ-point-spectrum-versus-flux","page":"Tutorial 5: Hofstadter Butterfly","title":"Γ-point spectrum versus flux","text":"","category":"section"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"flux_list, energies = Operators.hofstadter(hops, lat, 16)\np = scatter(\n    [float(ϕ) for (ϕ, e) in zip(flux_list, energies) for _ in e],\n    [e for es in energies for e in es];\n    ms=1.5,\n    alpha=0.6,\n    xlabel=\"Flux (ϕ/ϕ₀)\",\n    ylabel=\"Energy / t\",\n    size=(380, 300)\n)\nsavefig(p, joinpath(figdir, \"hofstadter_gamma.svg\"))\nnothing","category":"page"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"(Image: )","category":"page"},{"location":"tutorials/hofstadter/#Validation-checklist","page":"Tutorial 5: Hofstadter Butterfly","title":"Validation checklist","text":"","category":"section"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"Confirm the butterfly reproduces standard graphene features at rational flux values.\nCheck that saved data sizes line up with grid dimensions.\nCompare with reference plots in literature for sanity.","category":"page"},{"location":"tutorials/hofstadter/#Suggested-extensions","page":"Tutorial 5: Hofstadter Butterfly","title":"Suggested extensions","text":"","category":"section"},{"location":"tutorials/hofstadter/","page":"Tutorial 5: Hofstadter Butterfly","title":"Tutorial 5: Hofstadter Butterfly","text":"Cross-link results with linear-response calculations for quantised Hall conductance.\nIntroduce disorder or interaction effects using Meanfield or Superconductivity.\nAutomate meshes via extra/examples/graphene/hofstadter.jl for scripted runs.","category":"page"},{"location":"tutorials/superconductivity/#Tutorial-8-—-Superconductivity-(BdG)","page":"Tutorial 8: Superconductivity (BdG)","title":"Tutorial 8 — Superconductivity (BdG)","text":"","category":"section"},{"location":"tutorials/superconductivity/","page":"Tutorial 8: Superconductivity (BdG)","title":"Tutorial 8: Superconductivity (BdG)","text":"Model spin-singlet superconductivity via self-consistent Bogoliubov–de Gennes (BdG) mean-field on a single-layer graphene lattice. This example mirrors the parameters from an interacting honeycomb study (onsite attraction with mild nearest‑neighbour interaction, slight doping), and plots quasiparticle bands with particle/hole branches and the pairing gap.","category":"page"},{"location":"tutorials/superconductivity/#Learning-goals","page":"Tutorial 8: Superconductivity (BdG)","title":"Learning goals","text":"","category":"section"},{"location":"tutorials/superconductivity/","page":"Tutorial 8: Superconductivity (BdG)","title":"Tutorial 8: Superconductivity (BdG)","text":"Build a spinful graphene Hamiltonian and add a weak sublattice mass.\nConstruct a BdG operator and an attractive onsite interaction for s‑wave pairing.\nRun a self-consistent BdG (Hartree–Fock) cycle at slight doping.\nPlot the BdG bands and inspect the gap opening.","category":"page"},{"location":"tutorials/superconductivity/#Setup","page":"Tutorial 8: Superconductivity (BdG)","title":"Setup","text":"","category":"section"},{"location":"tutorials/superconductivity/#Self-consistent-BdG","page":"Tutorial 8: Superconductivity (BdG)","title":"Self-consistent BdG","text":"","category":"section"},{"location":"tutorials/superconductivity/","page":"Tutorial 8: Superconductivity (BdG)","title":"Tutorial 8: Superconductivity (BdG)","text":"ρ_sc, ϵ_GS, HF, converged, resid = Meanfield.solvehartreefock(\n    HBdG, V, ρ_init, filling; klin=klin, iterations=500, tol=1e-5,\n    T=0.001, β=0.75, show_trace=false\n)\nprintln(\"Converged: \", converged, \", residual = \", resid)","category":"page"},{"location":"tutorials/superconductivity/","page":"Tutorial 8: Superconductivity (BdG)","title":"Tutorial 8: Superconductivity (BdG)","text":"# Extract the full BdG mean-field Hamiltonian and chemical potential\nHBdG_mf = Meanfield.hMF(HF)\nμ = HF.μ\nocc = Spectrum.filling(HBdG_mf, μ; nk=klin)\nprintln(\"μ = \", round(μ, digits=4), \", filling ≈ \", round(occ, digits=3))\nsize(HBdG_mf([0.0, 0.0]))","category":"page"},{"location":"tutorials/superconductivity/#Bands-and-pairing-gap","page":"Tutorial 8: Superconductivity (BdG)","title":"Bands and pairing gap","text":"","category":"section"},{"location":"tutorials/superconductivity/","page":"Tutorial 8: Superconductivity (BdG)","title":"Tutorial 8: Superconductivity (BdG)","text":"figdir = joinpath(pwd(), \"figures\"); mkpath(figdir)\nks = kpath(lat; num_points=200) # Γ–K–M–Γ path\n# Shift by chemical potential for plotting parity with legacy script\nOperators.addchemicalpotential!(HBdG_mf, -μ)\n# Colour by electron weight using an electron-sector projector function\neP = k -> Superconductivity.electron(HBdG_mf)(k)\nbands_bdg = Spectrum.getbands(HBdG_mf, ks, eP)\n# Plot symmetric window around zero to highlight particle/hole branches\np = plot(bands_bdg, 1; marker=:none, size=(520, 320),\n         ylabel=\"ε/t\", title=\"Graphene BdG bands (Δ ≠ 0)\",\n         colorbar=true, colorbar_title=\"electron weight\")\nsavefig(p, joinpath(figdir, \"graphene_bdg_bands.svg\"))\nnothing","category":"page"},{"location":"tutorials/superconductivity/","page":"Tutorial 8: Superconductivity (BdG)","title":"Tutorial 8: Superconductivity (BdG)","text":"(Image: )","category":"page"},{"location":"tutorials/superconductivity/","page":"Tutorial 8: Superconductivity (BdG)","title":"Tutorial 8: Superconductivity (BdG)","text":"Tip: Increase |U| or k‑point density for a larger/cleaner gap at the cost of runtime. To verify s‑wave symmetry, inspect the local pairing observable via Operators.localobservables(ρ_sc, lat).","category":"page"},{"location":"tutorials/superconductivity/#Common-pitfalls","page":"Tutorial 8: Superconductivity (BdG)","title":"Common pitfalls","text":"","category":"section"},{"location":"tutorials/superconductivity/","page":"Tutorial 8: Superconductivity (BdG)","title":"Tutorial 8: Superconductivity (BdG)","text":"If self-consistency oscillates, reduce the mixing parameter (e.g. β=0.5) or initialise with a uniform seed instead of a random one.\nThe sign convention for doping follows electron filling; values below 0.5 indicate electron doping in the spinful model.","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page helps you install LatticeQM, pick an execution environment, and run a five-minute graphene example that exercises the core APIs.","category":"page"},{"location":"getting_started/#Choose-your-environment","page":"Getting Started","title":"Choose your environment","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Docker quickstart (recommended for a zero-friction demo).\nVS Code + Remote Containers (integrated development environment).\nNative Julia installation (for long-lived local setups and HPC nodes).","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Regardless of setup, the tutorials and examples share the same project environment, so data written inside containers is available on the host.","category":"page"},{"location":"getting_started/#Option-A-—-Docker-quickstart","page":"Getting Started","title":"Option A — Docker quickstart","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Install Docker.\nFrom the repository root run:\ndocker-compose up --build\nThis spins up a container with Julia, Python, and Jupyter configured.\nOpen the Jupyter URL printed in the terminal, navigate to extra/tutorial, and launch the desired notebook.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The folders extra/examples and extra/tutorial are mounted as volumes, so any changes you make inside the container persist on the host filesystem.","category":"page"},{"location":"getting_started/#Option-B-—-VS-Code-Remote-Containers","page":"Getting Started","title":"Option B — VS Code Remote Containers","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Install Docker, VS Code, and the Remote - Containers extension.\nOpen the repository in VS Code. The editor prompts you to reopen in a container; accept to reuse the same configuration as the Docker quickstart.\nUse the integrated terminal or notebook UI to run tutorials and examples.","category":"page"},{"location":"getting_started/#Option-C-—-Native-Julia-installation","page":"Getting Started","title":"Option C — Native Julia installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Install the latest stable Julia release (≥1.10 recommended).\nAdd the package from the General registry:\nusing Pkg\nPkg.add(\"LatticeQM\")\nFor development work use Pkg.develop(path=\"/path/to/LatticeQM\").\nInstantiate dependencies in the project environment:\njulia --project=.\nusing Pkg; Pkg.instantiate()\nUpdate periodically with Pkg.update().","category":"page"},{"location":"getting_started/#Five-minute-graphene-example","page":"Getting Started","title":"Five-minute graphene example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Run the following snippet from a Julia REPL started with --project=. to verify that everything is wired correctly.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Plots\nusing LatticeQM\n\nlat = Geometries.honeycomb()\nhops = Operators.graphene(lat; mode=:spinhalf)\nOperators.addzeeman!(hops, lat, 0.2)\n\nvalley = Operators.valley(lat; spinhalf=true)\nks = kpath(lat; num_points=200)\nbands = getbands(hops, ks, valley)\n\nplot(bands; ylabel=\"ε/t\", colorbar_title=\"valley\", size=(330, 200),\n     colorbar=true, markercolor=:PiYG)\nmkpath(\"figures\") # hide\nsavefig(\"figures/graphene_bands_zeeman.svg\") # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The script plots graphene bands with Zeeman splitting and stores the figure at figures/graphene_bands_zeeman.svg.","category":"page"},{"location":"getting_started/#Troubleshooting","page":"Getting Started","title":"Troubleshooting","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Package not found: ensure you launched Julia with --project=. or called Pkg.activate(\".\").\nPlots backend errors: install a compatible GR or Plotly backend (Pkg.add(\"GR\")) or run inside the Docker container where it is preinstalled.\nLong instantiation times: precompile packages with julia --project=. -e 'using Pkg; Pkg.precompile()' before running notebooks.","category":"page"},{"location":"getting_started/#Next-steps","page":"Getting Started","title":"Next steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Continue with Tutorial 1 for a deep dive into lattice construction.\nExplore scripts under extra/examples/ for batch-ready workflows, or continue with additional tutorials.","category":"page"},{"location":"guides/observables/#Concept-Guide-—-Observables-and-Spectral-Analysis","page":"Observables & Spectral Analysis","title":"Concept Guide — Observables & Spectral Analysis","text":"","category":"section"},{"location":"guides/observables/","page":"Observables & Spectral Analysis","title":"Observables & Spectral Analysis","text":"Analyse bands, densities of states, Berry curvature, and linear-response coefficients using the Spectrum, LinearResponse, and Plotting modules.","category":"page"},{"location":"guides/observables/#Spectrum-essentials","page":"Observables & Spectral Analysis","title":"Spectrum essentials","text":"","category":"section"},{"location":"guides/observables/","page":"Observables & Spectral Analysis","title":"Observables & Spectral Analysis","text":"Spectrum.getbands(hops, ks, op=nothing) computes eigenvalues and, if an operator is supplied, expectation values along the k-path.\nSpectrum.getdos(hops, emin, emax; klin, Γ, format) returns density-of-states estimates. For large systems use format=:sparse.\nSpectrum.chern and related routines derive topological invariants from eigenvectors or Wilson loops.","category":"page"},{"location":"guides/observables/#Berry-phases-and-Wilson-loops","page":"Observables & Spectral Analysis","title":"Berry phases & Wilson loops","text":"","category":"section"},{"location":"guides/observables/","page":"Observables & Spectral Analysis","title":"Observables & Spectral Analysis","text":"lat = Geometries.honeycomb()\nhops = Operators.graphene(lat)\nloops = Spectrum.wilsonloop(hops; nk=200, bands=1:2)","category":"page"},{"location":"guides/observables/","page":"Observables & Spectral Analysis","title":"Observables & Spectral Analysis","text":"Inspect the SSH×SSH example (extra/examples/SSHxSSH/wilsonloop.jl) for a working script.\nNormalise phases to maintain continuity; unwrap when plotting.","category":"page"},{"location":"guides/observables/#Linear-response","page":"Observables & Spectral Analysis","title":"Linear response","text":"","category":"section"},{"location":"guides/observables/","page":"Observables & Spectral Analysis","title":"Observables & Spectral Analysis","text":"LinearResponse.opticalconductivity and friends evaluate conductivities using Kubo formulas. See extra/examples/graphene/opticalconductivity.jl.\nPay attention to broadening parameters and sum-rule checks.","category":"page"},{"location":"guides/observables/#Plotting-recipes","page":"Observables & Spectral Analysis","title":"Plotting recipes","text":"","category":"section"},{"location":"guides/observables/","page":"Observables & Spectral Analysis","title":"Observables & Spectral Analysis","text":"Plotting.plot(bands; kwargs...) produces band plots with colour bars, annotated symmetry points, and legend customisation.\nFor density-of-states, combine Plots with returned arrays to overlay multiple datasets.","category":"page"},{"location":"guides/observables/#Best-practices","page":"Observables & Spectral Analysis","title":"Best practices","text":"","category":"section"},{"location":"guides/observables/","page":"Observables & Spectral Analysis","title":"Observables & Spectral Analysis","text":"Cache k-paths and operators when scanning parameters to avoid recomputation.\nFor extensive sweeps, stream results to disk (HDF5, JLD2) and perform plotting in a separate step to decouple compute from rendering.\nDocument numerical tolerances (Γ, nk, integration step) alongside figures so others can reproduce them.","category":"page"},{"location":"guides/operators/#Concept-Guide-—-Operators-and-Hamiltonians","page":"Operators & Hamiltonians","title":"Concept Guide — Operators & Hamiltonians","text":"","category":"section"},{"location":"guides/operators/","page":"Operators & Hamiltonians","title":"Operators & Hamiltonians","text":"The LatticeQM.Operators and LatticeQM.TightBinding modules provide tools to build and manipulate tight-binding Hamiltonians. This guide complements Tutorials 2–4 and the repository examples under extra/examples/.","category":"page"},{"location":"guides/operators/#Core-abstractions","page":"Operators & Hamiltonians","title":"Core abstractions","text":"","category":"section"},{"location":"guides/operators/","page":"Operators & Hamiltonians","title":"Operators & Hamiltonians","text":"TightBinding.Hops: sparse dictionary mapping lattice displacements to hopping matrices. Use DenseHops/SparseHops wrappers to convert storage.\nOperators.graphene(lat; mode=:spinhalf): convenience constructor for graphene-like models. Other helpers generate Rashba, Zeeman, or Haldane terms.\nOperators.gethops(lat, f): generate hoppings from a lattice and a distance function f(r₁, r₂).","category":"page"},{"location":"guides/operators/#Building-Hamiltonians","page":"Operators & Hamiltonians","title":"Building Hamiltonians","text":"","category":"section"},{"location":"guides/operators/","page":"Operators & Hamiltonians","title":"Operators & Hamiltonians","text":"lat = Geometries.honeycomb()\nhops = Operators.graphene(lat; mode=:spinhalf)\nOperators.addzeeman!(hops, lat, 0.2)\nOperators.addhaldane!(hops, lat, 0.1; spinhalf=true)","category":"page"},{"location":"guides/operators/","page":"Operators & Hamiltonians","title":"Operators & Hamiltonians","text":"Compose multiple terms by calling mutation helpers in sequence.\nUse addhops!(Hops(), lat, f) when building models from scratch; the helper automatically populates displacement keys.\nConvert to matrices with TightBinding.getbloch(hops) or pass hops to spectrum utilities directly.","category":"page"},{"location":"guides/operators/#Observables-and-projectors","page":"Operators & Hamiltonians","title":"Observables & projectors","text":"","category":"section"},{"location":"guides/operators/","page":"Operators & Hamiltonians","title":"Operators & Hamiltonians","text":"Construct observables (valley, layer, spin) with dedicated helpers, e.g. Operators.valley(lat; spinhalf=true).\nFor density matrices, rely on utilities in src/modules/Operators/densitymatrix.jl. Document any advanced use (partial traces, symmetrisation) as you extend coverage.","category":"page"},{"location":"guides/operators/#Managing-sparsity","page":"Operators & Hamiltonians","title":"Managing sparsity","text":"","category":"section"},{"location":"guides/operators/","page":"Operators & Hamiltonians","title":"Operators & Hamiltonians","text":"Prefer sparse storage for large systems (SparseHops(hops)).\nUse TightBinding.hopdim(hops) to inspect matrix dimensions before allocating.\nBenchmark conversions for your problem sizes and record the settings that balance accuracy and runtime.","category":"page"},{"location":"guides/operators/#Quality-checks","page":"Operators & Hamiltonians","title":"Quality checks","text":"","category":"section"},{"location":"guides/operators/","page":"Operators & Hamiltonians","title":"Operators & Hamiltonians","text":"Verify Hermiticity by confirming hops[δ] and hops[-δ] are conjugate transposes.\nFor custom terms, write smoke tests that diagonalise a representative system and compare to analytical expectations.","category":"page"},{"location":"guides/operators/#Where-to-go-next","page":"Operators & Hamiltonians","title":"Where to go next","text":"","category":"section"},{"location":"guides/operators/","page":"Operators & Hamiltonians","title":"Operators & Hamiltonians","text":"Combine with the Mean-field guide to incorporate interaction-driven terms.\nReference the API page for the full list of exported constructors once docstrings are standardised.","category":"page"},{"location":"tutorials/bands/#Tutorial-2-—-Band-Structures","page":"Tutorial 2: Band Structures","title":"Tutorial 2 — Band Structures","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"Notebook: extra/tutorial/Tutorial2_Bands.ipynb","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"This tutorial takes the lattices defined earlier and constructs tight-binding Hamiltonians to compute band structures, colour maps, and expectation values.","category":"page"},{"location":"tutorials/bands/#Learning-goals","page":"Tutorial 2: Band Structures","title":"Learning goals","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"Build graphene Hamiltonians with Operators.graphene and optional modifiers (Operators.addzeeman!, Operators.addhaldane!, etc.).\nSample Brillouin-zone paths using LatticeQM.kpath and customise the resolution.\nCompute band energies and operator expectation values with Spectrum.getbands.\nProduce publication-ready plots via LatticeQM.Plotting.plot.","category":"page"},{"location":"tutorials/bands/#Prerequisites","page":"Tutorial 2: Band Structures","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"Familiarity with the Structure module (Tutorial 1).\nPlots and ColorSchemes available if you plan to tweak the visuals.","category":"page"},{"location":"tutorials/bands/#Workflow-outline","page":"Tutorial 2: Band Structures","title":"Workflow outline","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"Hamiltonian assembly — Start from a lattice and call hops = Operators.graphene(lat; mode=:spinhalf).\nOperator augmentation — Add Zeeman or Haldane terms: Operators.addzeeman!(hops, lat, Δ) or Operators.addhaldane!(...).\nMomentum path — Generate a default high-symmetry path using ks = kpath(lat; num_points=200). Override the path to explore custom cuts.\nBands & observables — Evaluate bands = getbands(hops, ks, optional_operator); inspect the attached data.\nPlotting — Call plot(bands; ylabel=\"ε/t\", colorbar=true, ...) to render coloured dispersions, saving figures to output/.","category":"page"},{"location":"tutorials/bands/#Live-example-—-nearest-neighbour-model","page":"Tutorial 2: Band Structures","title":"Live example — nearest-neighbour model","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"figdir = joinpath(pwd(), \"figures\")\nmkpath(figdir)\nnothing","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"bands = getbands(hops, ks, valley)\nfirst(bands.bands, 3)","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"p = plot(\n    bands;\n    ylabel=\"ε/t\",\n    size=(400, 250),\n    marker=:none,\n    colorbar=true,\n    colorbar_title=\"valley\"\n)\nsavefig(p, joinpath(figdir, \"graphene_bands_valley.svg\"))\nnothing","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"(Image: )","category":"page"},{"location":"tutorials/bands/#Manual-construction-of-hoppings","page":"Tutorial 2: Band Structures","title":"Manual construction of hoppings","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"lat_simple = Geometries.honeycomb()\nfunction nn_hop(r1, r2=0.0)\n    δ = r1 .- r2\n    return 0.9 < norm(δ[1:3]) < 1.1 ? -1.0 : 0.0\nend\nHnn = TightBinding.Hops(lat_simple, nn_hop)\nks_dense = kpath(lat_simple; num_points=140)\nbands_nn = getbands(Hnn, ks_dense)\np = plot(bands_nn; size=(360, 220), xlabel=\"k\", ylabel=\"ε/t\")\nsavefig(p, joinpath(figdir, \"nearest_neighbor_bands.svg\"))\nnothing","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"(Image: )","category":"page"},{"location":"tutorials/bands/#Pre-defined-operators-and-imbalance","page":"Tutorial 2: Band Structures","title":"Pre-defined operators and imbalance","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"h_pre = Hops()\nOperators.nearestneighbor!(h_pre, lat_simple)\nOperators.addchemicalpotential!(h_pre, lat_simple, r -> (r[4] == 0) ? 0.2 : -0.2)\nbands_pre = getbands(h_pre, ks_dense)\np = plot(bands_pre; size=(360, 220), xlabel=\"k\")\nsavefig(p, joinpath(figdir, \"predefined_imbalance.svg\"))\nnothing","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"(Image: )","category":"page"},{"location":"tutorials/bands/#Expectation-values","page":"Tutorial 2: Band Structures","title":"Expectation values","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"h_spin = Hops()\nOperators.nearestneighbor!(h_spin, lat)\nOperators.addsublatticeimbalance!(h_spin, lat, 0.5)\nh_spin = TightBinding.addspin(h_spin, :spinhalf)\nOperators.addzeeman!(h_spin, lat, 0.15)\nsz = Operators.spin(lat, \"sz\")\nvalley = Operators.valley(lat; spinhalf=true)\nbands_obs = getbands(h_spin, ks, [sz, valley])\nplot(bands_obs, 1; size=(360, 220), colorbar_title=\"spin\")","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"plot(bands_obs, 2; size=(360, 220), colorbar_title=\"valley\")","category":"page"},{"location":"tutorials/bands/#Ribbons","page":"Tutorial 2: Band Structures","title":"Ribbons","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"N = 8\nlat_armchair = Structure.Lattices.reduceto1D(Geometries.honeycomb(), [[1, 1] [N, -N]])\nlat_zigzag = Structure.Lattices.reduceto1D(Geometries.honeycomb(), [[1, 0] [0, N]])\nh_arm = Operators.graphene(lat_armchair)\nh_zig = Operators.graphene(lat_zigzag)\nks_ribbon = kpath(lat_armchair; num_points=120)\nbands_arm = getbands(h_arm, ks_ribbon)\nbands_zig = getbands(h_zig, ks_ribbon)\np = plot(\n    plot(lat_armchair, \"sublattice\"; supercell=[20], markersize=2, title=\"Armchair\", size=(320, 220)),\n    plot(bands_arm; size=(320, 220), xlabel=\"k\"),\n    plot(lat_zigzag, \"sublattice\"; supercell=[20], markersize=2, title=\"Zigzag\", size=(320, 220)),\n    plot(bands_zig; size=(320, 220), xlabel=\"k\"),\n    layout=(2, 2), size=(660, 420)\n)\nsavefig(p, joinpath(figdir, \"ribbon_comparison.svg\"))\nnothing","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"(Image: )","category":"page"},{"location":"tutorials/bands/#Density-of-States-(DOS)","page":"Tutorial 2: Band Structures","title":"Density of States (DOS)","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"# Align with the example script: spin-1/2 graphene, dense storage, no Zeeman\nlat_dos = Geometries.honeycomb()\nhops_dos = DenseHops(Operators.graphene(lat_dos; mode=:spinhalf))\nenergies, dos = Spectrum.getdos(hops_dos, -3.1, 3.1; klin=800, format=:dense, Γ=0.005)\np = plot(energies, dos; xlabel=\"Energy / t\", ylabel=\"DOS\", size=(380, 240), linewidth=2)\nsavefig(p, joinpath(figdir, \"graphene_dos_full.svg\"))\nnothing","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"(Image: )","category":"page"},{"location":"tutorials/bands/#Optical-Conductivity-(graphene)","page":"Tutorial 2: Band Structures","title":"Optical Conductivity (graphene)","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"lat2 = Geometries.honeycomb()\nhops2 = Operators.graphene(lat2; format=:dense, mode=:nospin)\nOperators.addsublatticeimbalance!(hops2, lat2, 0.001)\nfreqs = LinRange(0.0, 4.0, 180)\nΓ = 0.02\nσ = LinearResponse.opticalconductivity(freqs, 1, 1, hops2, lat2; klin=220, T=0.001, Γ=Γ)\nσ = -(σ .- σ[begin]) ./ (freqs .+ 1im * Γ)\np = plot(freqs, π .* real(σ); label=\"Re\", xlabel=\"ω/t\", ylabel=\"πσ(ω)\", size=(420, 260))\nplot!(p, freqs, π .* imag(σ); label=\"Im\")\nsavefig(p, joinpath(figdir, \"graphene_optical_conductivity.svg\"))\nnothing","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"(Image: )","category":"page"},{"location":"tutorials/bands/#Fermi-Surface-Density-(doped-graphene)","page":"Tutorial 2: Band Structures","title":"Fermi Surface Density (doped graphene)","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"E_F = 0.30 # shift to reveal circular pockets near K/K′\nkgrid, ρ = Spectrum.fermisurfacedensity(hops2, [E_F]; num_points=45)\nK = Structure.Lattices.getB(lat2) * kgrid\np = scatter(K[1, :], K[2, :]; marker_z=vec(ρ), ms=3.0, markerstrokewidth=0, colorbar=true,\n            xlabel=\"k₁\", ylabel=\"k₂\", size=(420, 320), markercolor=:viridis,\n            aspect_ratio=:equal)\nsavefig(p, joinpath(figdir, \"graphene_fermi_surface_density.svg\"))\nnothing","category":"page"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"(Image: )","category":"page"},{"location":"tutorials/bands/#Validation-checklist","page":"Tutorial 2: Band Structures","title":"Validation checklist","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"Ensure symmetry points (Γ, K, M) are labelled as expected.\nCompare band degeneracies against analytical graphene results.\nCheck that saved figures mirror those in the tutorial.","category":"page"},{"location":"tutorials/bands/#Suggested-extensions","page":"Tutorial 2: Band Structures","title":"Suggested extensions","text":"","category":"section"},{"location":"tutorials/bands/","page":"Tutorial 2: Band Structures","title":"Tutorial 2: Band Structures","text":"Replace Operators.graphene with your own Hops definition for custom materials.\nExport band data with save(bands, \"bands.h5\") and post-process elsewhere.\nCombine with Spectrum.getdos (see Graphene examples) to correlate density of states and dispersion features.","category":"page"},{"location":"guides/floquet/#Concept-Guide-—-Floquet-Workflows","page":"Floquet Workflows","title":"Concept Guide — Floquet Workflows","text":"","category":"section"},{"location":"guides/floquet/","page":"Floquet Workflows","title":"Floquet Workflows","text":"Periodic driving introduces additional structure beyond static lattice Hamiltonians. The Floquet module (developed with Tobias Kästli during his Master's project) provides convenience APIs for constructing and analysing driven systems.","category":"page"},{"location":"guides/floquet/#Core-functions","page":"Floquet Workflows","title":"Core functions","text":"","category":"section"},{"location":"guides/floquet/","page":"Floquet Workflows","title":"Floquet Workflows","text":"Floquet.makefloquet(hops; harmonics, ω, gauge): build the truncated Floquet Hamiltonian by stacking harmonic sectors.\nFloquet.getspectrum(floquet_hops; kwargs...): obtain quasienergies and states.\nFloquet.makeobservable(op; harmonics): lift static observables to Floquet space for expectation-value calculations.","category":"page"},{"location":"guides/floquet/#Workflow-checkpoints","page":"Floquet Workflows","title":"Workflow checkpoints","text":"","category":"section"},{"location":"guides/floquet/","page":"Floquet Workflows","title":"Floquet Workflows","text":"Static baseline — Assemble the non-driven Hamiltonian using Operators.\nDrive specification — Encode vector potentials or onsite modulations with helper functions (e.g. Floquet.circular_drive).\nHarmonic truncation — Choose harmonic count based on drive strength; verify convergence by increasing the cutoff until spectra stabilise.\nDiagonalisation — Solve for quasienergies; classify them modulo the drive frequency.\nObservables — Evaluate micromotion, time-averaged expectation values, or Floquet-broadened densities of states.","category":"page"},{"location":"guides/floquet/#Numerical-tips","page":"Floquet Workflows","title":"Numerical tips","text":"","category":"section"},{"location":"guides/floquet/","page":"Floquet Workflows","title":"Floquet Workflows","text":"Use sparse representations; Floquet Hamiltonians are block-structured and can grow rapidly with harmonic count.\nNormalise phases consistently across harmonics to avoid discontinuities in observables.\nProfile memory/time with representative parameters; record findings in the Advanced Workflows section.","category":"page"},{"location":"guides/floquet/#Further-reading","page":"Floquet Workflows","title":"Further reading","text":"","category":"section"},{"location":"guides/floquet/","page":"Floquet Workflows","title":"Floquet Workflows","text":"Tutorial: Floquet Dynamics for a guided example.\nExamples: Extend the graphene scripts by adding periodic drives and compare static vs. driven observables.","category":"page"},{"location":"tutorials/floquet/#Tutorial-7-—-Floquet-Dynamics","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7 — Floquet Dynamics","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"Notebook: extra/tutorial/Tutorial7_Floquet.ipynb","category":"page"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"Learn how to model periodically driven systems using the LatticeQM.Floquet module and interpret quasienergy spectra.","category":"page"},{"location":"tutorials/floquet/#Learning-goals","page":"Tutorial 7: Floquet Dynamics","title":"Learning goals","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"Build Floquet Hamiltonians from static tight-binding models and driving protocols.\nTruncate harmonic spaces judiciously to capture resonant processes.\nCompute quasienergy spectra and track avoided crossings.\nEvaluate time-averaged observables and micromotion.","category":"page"},{"location":"tutorials/floquet/#Prerequisites","page":"Tutorial 7: Floquet Dynamics","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"Tutorials 1–2 for standard Hamiltonian workflows.\nBasic understanding of Floquet theory.","category":"page"},{"location":"tutorials/floquet/#Workflow-outline","page":"Tutorial 7: Floquet Dynamics","title":"Workflow outline","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"Base model — Start with a lattice and tight-binding Hamiltonian (graphene or a custom model).\nDrive specification — Define periodic fields via helper constructors in Floquet (e.g. circularly polarised light, pulsed fields).\nFloquet construction — Use Floquet.makefloquet(hops; harmonics, ω) or equivalent functions demonstrated in the notebook.\nDiagonalisation — Solve for quasienergies with Floquet.getspectrum or the standard Spectrum.getbands applied to the extended Hamiltonian.\nObservables — Analyse mode occupations, compute time-averaged currents, and export plots.","category":"page"},{"location":"tutorials/floquet/#Live-example","page":"Tutorial 7: Floquet Dynamics","title":"Live example","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"Floquet.periodicDrive(5.0)","category":"page"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"figdir = joinpath(pwd(), \"figures\")\nmkpath(figdir)\nnothing","category":"page"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"bands = getbands(HF, ks)\nFloquet.keepfirstFBZ!(bands, HF)\nfirst(bands.bands, 3)","category":"page"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"p = plot(bands; ylabel=\"ε/t\", marker=:none, size=(380, 240), title=\"Floquet quasienergies (first zone)\")\nsavefig(p, joinpath(figdir, \"floquet_bands.svg\"))\nnothing","category":"page"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"(Image: )","category":"page"},{"location":"tutorials/floquet/#Chern-numbers-for-driven-graphene-(toy-amplitude)","page":"Tutorial 7: Floquet Dynamics","title":"Chern numbers for driven graphene (toy amplitude)","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"N = size(HF(ks.points[:, 1]), 1) ÷ 2\nchern_vals = Spectrum.getcherns(HF, 16, 16, N-1:N+2)\nchern_vals","category":"page"},{"location":"tutorials/floquet/#Two-band-toy-model","page":"Tutorial 7: Floquet Dynamics","title":"Two-band toy model","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"static_cherns = Spectrum.getcherns(HB, 12, 12)\nstatic_cherns","category":"page"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"p = plot(bands_static; size=(360, 240), title=\"Static two-band model\")\nsavefig(p, joinpath(pwd(), \"figures\", \"floquet_static.svg\"))\nnothing","category":"page"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"(Image: )","category":"page"},{"location":"tutorials/floquet/#Driven-two-band-model","page":"Tutorial 7: Floquet Dynamics","title":"Driven two-band model","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"ω = 12.0\nD = 0.8\nM = 3\ndrive2 = Floquet.periodicDrive(ω, [[D 0; 0 -D], [D 0; 0 -D]], [1, -1])\nHF2 = Floquet.FloquetOperator(HB, drive2, M)\nbands_driven = Spectrum.getbands(HF2, path2)\nFloquet.keepfirstFBZ!(bands_driven, HF2)\np = plot(bands_driven; size=(360, 240), title=\"Driven bands\", ylims=(-ω/2, ω/2))\nsavefig(p, joinpath(pwd(), \"figures\", \"floquet_driven.svg\"))\nnothing","category":"page"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"(Image: )","category":"page"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"chern_drive = Spectrum.getcherns(HF2, 12, 12, [2M + 1])\nwind_drive = Spectrum.getwindnum(HF2, 12, 12, 2M + 1)\n(chern_drive, wind_drive)","category":"page"},{"location":"tutorials/floquet/#Validation-checklist","page":"Tutorial 7: Floquet Dynamics","title":"Validation checklist","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"Confirm quasienergy zones repeat modulo the drive frequency.\nCompare against static limits (ω → ∞) to ensure convergence.\nSave plots (typically under output/floquet/) and verify they match the notebook reference.","category":"page"},{"location":"tutorials/floquet/#Common-pitfalls","page":"Tutorial 7: Floquet Dynamics","title":"Common pitfalls","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"Insufficient harmonic truncation can create spurious gaps. Increase M until bands and observables stabilise.\nBeware energy folding: always compare spectra modulo ω and consider calling Floquet.keepfirstFBZ! before plotting.\nFor large systems, prefer sparse types and limit the number of requested bands to keep memory in check.","category":"page"},{"location":"tutorials/floquet/#Suggested-extensions","page":"Tutorial 7: Floquet Dynamics","title":"Suggested extensions","text":"","category":"section"},{"location":"tutorials/floquet/","page":"Tutorial 7: Floquet Dynamics","title":"Tutorial 7: Floquet Dynamics","text":"Couple Floquet results to linear-response calculations to estimate pump-probe signatures.\nExplore different truncation strategies and document runtime vs. accuracy.\nBenchmark parallel execution where available and capture typical runtimes for your hardware and parameter choices.","category":"page"},{"location":"#LatticeQM-Documentation","page":"Home","title":"LatticeQM Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LatticeQM is a Julia toolkit for building lattice models, constructing tight-binding Hamiltonians, and analysing electronic structure across a broad set of workflows (band structures, topology, mean-field, Floquet dynamics).","category":"page"},{"location":"#Choose-your-path","page":"Home","title":"Choose your path","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Getting Started — installation, environment setup, and a five-minute graphene example.\nTutorials — guided Jupyter notebooks spanning lattice construction to Floquet physics.\nConcept Guides — deeper discussions of geometry, operator construction, observables, and interactions.\nAdvanced Workflows — performance tuning, batch runs, and data management strategies.\nAPI Reference — auto-generated listings of exported names once docstrings are standardised.\nContributor Guide — development workflow, testing, and release coordination.","category":"page"},{"location":"#What-you'll-find-here","page":"Home","title":"What you'll find here","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Physics-driven examples: graphene, multilayer systems, twisted bilayers, Hubbard mean-field, and Floquet drives.\nExecutable walkthroughs: tutorial pages run during the doc build, regenerating lightweight figures and outputs.\nExtensible architecture: modular subpackages (Structure, Spectrum, Meanfield, Floquet, etc.) designed to be recombined.","category":"page"},{"location":"#Staying-up-to-date","page":"Home","title":"Staying up to date","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When new capabilities land (e.g. superconductivity utilities, advanced Berry diagnostics), open an issue or discussion to suggest additional examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"getting_started.md\",\n    \"tutorials/index.md\",\n    \"guides/geometry.md\",\n    \"advanced/index.md\",\n    \"contributing.md\",\n    \"api.md\"\n]\nDepth = 2","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I thank Dr. Oded Zilberberg and Dr. Gianni Blatter for their guidance and support as my thesis advisors; I developed the package in the course of my PhD research. \nTobias Kästli (@vigoleis) contributed the Floquet module as part of his Master's project and authored the accompanying tutorial.","category":"page"},{"location":"#Author","page":"Home","title":"Author","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dr. Tobias Wolf","category":"page"},{"location":"tutorials/hall_effect/#Tutorial-3-—-Haldane-Model-and-Topology","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3 — Haldane Model & Topology","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"Notebook: extra/tutorial/Tutorial3_Haldane.ipynb","category":"page"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"Explore how to induce topological gaps in graphene-like systems and compute observables that diagnose Chern insulating phases.","category":"page"},{"location":"tutorials/hall_effect/#Learning-goals","page":"Tutorial 3: Haldane Model & Topology","title":"Learning goals","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"Introduce complex next-nearest-neighbour hoppings via Operators.addhaldane!.\nStudy phase diagrams by sweeping Haldane mass and onsite potentials.\nEvaluate Berry curvature and Chern numbers with Spectrum utilities.\nVisualise chiral edge states on ribbon geometries.","category":"page"},{"location":"tutorials/hall_effect/#Prerequisites","page":"Tutorial 3: Haldane Model & Topology","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"Outcomes from Tutorial 2 (band-structure workflows).\nOptional: knowledge of topological band theory terminology.","category":"page"},{"location":"tutorials/hall_effect/#Workflow-outline","page":"Tutorial 3: Haldane Model & Topology","title":"Workflow outline","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"Model setup — Build a honeycomb lattice and baseline graphene Hamiltonian.\nHaldane term — Apply Operators.addhaldane!(hops, lat, φ; spinhalf=true) and optionally stack with sublattice imbalance.\nParameter scans — Use simple loops or range objects to inspect phase transitions. Store observables with @save or by writing CSV/JSON.\nTopological invariants — Invoke Spectrum.chern(hops, ks; ...) or related helpers to compute Chern numbers.\nRibbon perspective — Transform to ribbon geometries (see extra/examples/graphene/ribbon_haldane.jl) and plot edge-localised states.","category":"page"},{"location":"tutorials/hall_effect/#Live-example","page":"Tutorial 3: Haldane Model & Topology","title":"Live example","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"figdir = joinpath(pwd(), \"figures\")\nmkpath(figdir)\nnothing","category":"page"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"cherns = Spectrum.getcherns(hops, 15, 15)\nprintln(\"Chern numbers (lowest two) = \", cherns[1:2])","category":"page"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"p = plot(\n    getbands(hops, ks, [valley]);\n    ylabel=\"ε/t\",\n    marker=:none,\n    size=(420, 260),\n    title=\"Haldane model band structure\",\n    colorbar=true,\n    colorbar_title=\"valley\"\n)\nsavefig(p, joinpath(figdir, \"haldane_bands.svg\"))\nnothing","category":"page"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"(Image: )","category":"page"},{"location":"tutorials/hall_effect/#Berry-curvature-map","page":"Tutorial 3: Haldane Model & Topology","title":"Berry curvature map","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"kgrid, berry = Spectrum.berry(hops, 20, 20, [1])\nvals = filter(!isnan, abs.(berry[:]))\nmaxval = isempty(vals) ? 1.0 : Statistics.quantile(vals, 0.98)\np = scatter(\n    (Structure.Lattices.getB(lat) * hcat(reshape(kgrid, :, 1)...))[1, :],\n    (Structure.Lattices.getB(lat) * hcat(reshape(kgrid, :, 1)...))[2, :];\n    marker_z = vec(berry),\n    markerstrokewidth=0,\n    markersize=3,\n    colorbar=true,\n    clims=(-maxval, maxval),\n    markercolor=:RdBu,\n    xlabel=\"k₁\",\n    ylabel=\"k₂\",\n    size=(360, 280),\n    legend=false,\n    aspect_ratio=:equal\n)\nsavefig(p, joinpath(figdir, \"haldane_berry.svg\"))\nnothing","category":"page"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"(Image: )","category":"page"},{"location":"tutorials/hall_effect/#Phase-diagram-(coarse-grid)","page":"Tutorial 3: Haldane Model & Topology","title":"Phase diagram (coarse grid)","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"using LaTeXStrings\nphi_vals = LinRange(-π, π, 25)\nm_vals = LinRange(-1.2, 1.2, 25)\nh0 = Operators.graphene(lat; mode=:nospin, format=:dense)\nC = fill(0.0, length(phi_vals), length(m_vals))\nfor (i, ϕ) in enumerate(phi_vals), (j, Δ) in enumerate(m_vals)\n    local_model = deepcopy(h0)\n    Operators.addsublatticeimbalance!(local_model, lat, Δ)\n    Operators.addhaldane!(local_model, lat, 0.2; ϕ=ϕ)\n    C[i, j] = sum(Spectrum.berry(local_model, 10, 10, [1])[2])\nend\np = heatmap(\n    phi_vals ./ π,\n    m_vals,\n    transpose(round.(C; digits=2));\n    xlabel=L\"\\phi/\\pi\",\n    ylabel=L\"m/t_2\",\n    colorbar_title=\"Chern\",\n    size=(420, 240),\n    color=:seismic\n)\nsavefig(p, joinpath(figdir, \"haldane_phase.svg\"))\nnothing","category":"page"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"(Image: )","category":"page"},{"location":"tutorials/hall_effect/#Ribbon-dispersion","page":"Tutorial 3: Haldane Model & Topology","title":"Ribbon dispersion","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"N = 20\nlat_ribbon = Structure.Lattices.reduceto1D(Geometries.honeycomb(), [[1, 1] [N, -N]])\nh_ribbon = Operators.graphene(lat_ribbon; mode=:nospin, format=:dense, cellrange=1)\nOperators.addhaldane!(h_ribbon, lat_ribbon, 0.25)\nposition = Operators.positionalong(lat_ribbon, Structure.Lattices.basis(lat_ribbon, 2); rescale=true, center=true)\nks_ribbon = kpath(lat_ribbon; num_points=140)\nbands_ribbon = getbands(h_ribbon, ks_ribbon, position)\np = plot(\n    bands_ribbon, 1;\n    ylabel=\"ε/t\",\n    colorbar_title=\"transverse position\",\n    csymmetric=true,\n    markersize=1.5,\n    size=(450, 260)\n)\nsavefig(p, joinpath(figdir, \"haldane_ribbon.svg\"))\nnothing","category":"page"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"(Image: )","category":"page"},{"location":"tutorials/hall_effect/#Nested-Wilson-Loops-(SSHSSH-snapshot)","page":"Tutorial 3: Haldane Model & Topology","title":"Nested Wilson Loops (SSH×SSH snapshot)","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"using LatticeQM.Structure.Lattices: Lattice, addbasis!, addorbital!, addextra!\nfunction SSHxSSH(t1X, t2X, t1Y, t2Y)\n    lat = Lattice()\n    addbasis!(lat, [1, 0]); addbasis!(lat, [0, 1]); addextra!(lat, \"sublattice\")\n    addorbital!(lat, [0,   0,   2]); addorbital!(lat, [1/2, 0,   4])\n    addorbital!(lat, [0, 1/2,   3]); addorbital!(lat, [1/2, 1/2, 1])\n    lat.specialpoints = LatticeQM.Geometries.kdict_sq\n    h = DenseHops()\n    h[[0,0]] = zeros(ComplexF64, 4, 4)\n    h[[0,0]][3,1] = t1X; h[[0,0]][2,3] = -t1Y; h[[0,0]][4,2] = t1X; h[[0,0]][1,4] = t1Y\n    h[[0,0]] += h[[0,0]]'\n    h[[1,0]] = zeros(ComplexF64, 4, 4); h[[1,0]][3,1] = t2X; h[[1,0]][2,4] = t2X; h[[-1,0]] = h[[1,0]]'\n    h[[0,1]] = zeros(ComplexF64, 4, 4); h[[0,1]][2,3] = -t2Y; h[[0,1]][4,1] = t2Y; h[[0,-1]] = h[[0,1]]'\n    lat, h\nend\nlatSSH, hSSH = SSHxSSH(0.5, 1.0, 0.5, 1.0)\npol1, U1, pol2, U2 = Spectrum.NestedWilson2D(hSSH, 60, 60, 1:2)\np = plot(scatter(collect(1:length(pol1[:,1])), pol1[:,1]; ms=3.0, label=\"1\"),\n         scatter(collect(1:length(pol1[:,2])), pol1[:,2]; ms=3.0, label=\"2\");\n         size=(420, 260), xlabel=\"k₂ index\", ylabel=\"polarisation k₁\")\nsavefig(p, joinpath(figdir, \"sshxssh_wilson.svg\"))\nnothing","category":"page"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"(Image: )","category":"page"},{"location":"tutorials/hall_effect/#Validation-checklist","page":"Tutorial 3: Haldane Model & Topology","title":"Validation checklist","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"Confirm Chern numbers match the expected ±1 quantisation when phases wrap.\nCreate plots of Berry curvature hotspots and verify symmetry.\nCompare ribbon spectra with bulk band gaps for consistency.","category":"page"},{"location":"tutorials/hall_effect/#Suggested-extensions","page":"Tutorial 3: Haldane Model & Topology","title":"Suggested extensions","text":"","category":"section"},{"location":"tutorials/hall_effect/","page":"Tutorial 3: Haldane Model & Topology","title":"Tutorial 3: Haldane Model & Topology","text":"Couple the model to linear-response routines in LinearResponse to compute Hall conductivities.\nIntroduce disorder or electric fields to study robustness of edge channels.\nExport topological markers for later visualisation using scripts in extra/examples/.","category":"page"}]
}
