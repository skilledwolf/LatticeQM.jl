<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · LatticeQM.jl</title><meta name="title" content="API Reference · LatticeQM.jl"/><meta property="og:title" content="API Reference · LatticeQM.jl"/><meta property="twitter:title" content="API Reference · LatticeQM.jl"/><meta name="description" content="Documentation for LatticeQM.jl."/><meta property="og:description" content="Documentation for LatticeQM.jl."/><meta property="twitter:description" content="Documentation for LatticeQM.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LatticeQM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Overview</a></li><li><a class="tocitem" href="../tutorials/structure/">Tutorial 1: Structure &amp; Geometry</a></li><li><a class="tocitem" href="../tutorials/bands/">Tutorial 2: Band Structures</a></li><li><a class="tocitem" href="../tutorials/hall_effect/">Tutorial 3: Haldane Model &amp; Topology</a></li><li><a class="tocitem" href="../tutorials/twisted_bilayers/">Tutorial 4: Twisted Bilayer Graphene</a></li><li><a class="tocitem" href="../tutorials/hofstadter/">Tutorial 5: Hofstadter Butterfly</a></li><li><a class="tocitem" href="../tutorials/meanfield/">Tutorial 6: Mean-field Self-Consistency</a></li><li><a class="tocitem" href="../tutorials/floquet/">Tutorial 7: Floquet Dynamics</a></li><li><a class="tocitem" href="../tutorials/superconductivity/">Tutorial 8: Superconductivity (BdG)</a></li></ul></li><li><span class="tocitem">Concept Guides</span><ul><li><a class="tocitem" href="../guides/geometry/">Geometry &amp; Lattices</a></li><li><a class="tocitem" href="../guides/operators/">Operators &amp; Hamiltonians</a></li><li><a class="tocitem" href="../guides/observables/">Observables &amp; Spectral Analysis</a></li><li><a class="tocitem" href="../guides/meanfield/">Mean-field &amp; Superconductivity</a></li><li><a class="tocitem" href="../guides/floquet/">Floquet Workflows</a></li></ul></li><li><a class="tocitem" href="../advanced/">Advanced Workflows</a></li><li><a class="tocitem" href="../contributing/">Contributor Guide</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Structure"><span>Structure</span></a></li><li><a class="tocitem" href="#TightBinding"><span>TightBinding</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li><li><a class="tocitem" href="#Spectrum"><span>Spectrum</span></a></li><li><a class="tocitem" href="#LinearResponse"><span>LinearResponse</span></a></li><li><a class="tocitem" href="#Meanfield"><span>Meanfield</span></a></li><li><a class="tocitem" href="#Superconductivity"><span>Superconductivity</span></a></li><li><a class="tocitem" href="#Floquet"><span>Floquet</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Utils"><span>Utils</span></a></li><li><a class="tocitem" href="#Common-Entrypoints"><span>Common Entrypoints</span></a></li></ul></li><li><a class="tocitem" href="../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/skilledwolf/LatticeQM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/skilledwolf/LatticeQM.jl/blob/master/extra/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This reference is generated from in‑source docstrings. Use Julia help mode (<code>?name</code>) in the REPL for the most up‑to‑date signatures and keyword defaults. Where available, cross‑links to tutorials and guides provide usage context.</p><p>The sections below list public and internal names grouped by submodule. Use Julia’s help mode (<code>?</code>) for inline documentation and follow cross-links back to tutorials and guides for practical context.</p><h2 id="Structure"><a class="docs-heading-anchor" href="#Structure">Structure</a><a id="Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Structure" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.rotation2D-Tuple{Any}" href="#LatticeQM.Structure.rotation2D-Tuple{Any}"><code>LatticeQM.Structure.rotation2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotation2D(θ)</code></pre><p>Returns the 2x2 rotation matrix R = R^T parametrized by the rotation angle θ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/rotate.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.rotation3D" href="#LatticeQM.Structure.rotation3D"><code>LatticeQM.Structure.rotation3D</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotation3D(θ, n=[0,0,1])</code></pre><p>Returns SO(3) rotation matrix parametrized by rotation angle θ and rotation axis n=[n1,n2,n3].</p><p>Note: This routine will always normalize n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/rotate.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.signedangle-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector)" href="#LatticeQM.Structure.signedangle-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector)"><code>LatticeQM.Structure.signedangle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">signedangle(e1::T,e2::T; z=nothing)</code></pre><p>returns the signed angle between 3D vectors e1 and e2. z should be the normal vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/rotate.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.Lattice" href="#LatticeQM.Structure.Lattices.Lattice"><code>LatticeQM.Structure.Lattices.Lattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lattice</code></pre><p>Type that contains all information about a lattice.</p><p><strong>Fields</strong></p><ul><li><code>basis::Matrix</code>: columns are basis vectors</li><li><code>latticedim::Int</code>: how many of the basis vectors are lattice vectors</li><li><code>spacecoordinates::Matrix</code>: columns are coordinates of orbitals in the unit cell (w.r.t. basis vectors)</li><li><code>extracoordinates::Matrix</code>: additional non-spatial coordinates (e.g., could be sublattice index)</li><li><code>extralabels::Dict</code>: labels for the non-spatial coordinates</li><li><code>specialpoints::LabeledPoints</code>: High-symmetry points of the lattice (see <code>?Structure.Paths.LabeledPoints</code>)</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Lattice(basis::Matrix)
Lattice(basis::Matrix [, latticedim::Int], spacecoordinates::Matrix [, extracoordinates::Matrix]; extralabels=Vector{String}(), specialpoints=LabeledPoints())</code></pre><p><strong>Property functions</strong></p><pre><code class="language-julia hljs">latticedim(lat::Lattice)
countorbitals(lat:Lattice)
spacedim(lat::Lattice)
extraspacedim(lat::Lattice)

hasdimension(lat::Lattice, name::String)
assertdimension(lat::Lattice, name::String)

basis(lat::Lattice, ...)
getA(lat::Lattice, ...)
getB(lat::Lattice, ...)

coordinates(lat::Lattice, ...)
positions(lat::Lattice, ...)
allpositions(lat::Lattice, ...)
extracoordinates(lat::Lattice, ...)

filterindices(lat::Lattice, name::String, condition::Function)</code></pre><p><strong>Method functions</strong></p><pre><code class="language-julia hljs">addbasis!
addorbital!
addorbitals!
addextra!
setextracoordinates!
fractionalize!
foldfractional
foldcoordinates!
rotatebasis!
rotatecoordinates!
translate!
displace!
displaceZ!
mirrorZ!
mirrorZ
newdimension!
mergelattices!
mergelattices</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/type.jl#L3-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.bistack-Tuple{LatticeQM.Structure.Lattices.Lattice, Float64}" href="#LatticeQM.Structure.Lattices.bistack-Tuple{LatticeQM.Structure.Lattices.Lattice, Float64}"><code>LatticeQM.Structure.Lattices.bistack</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bistack(lat, δz; fracshift=[0.0, 0.0])</code></pre><p>Create a bilayer by duplicating <code>lat</code> and offsetting the upper copy by <code>δz</code> along the third (z) coordinate. Optionally shift the second layer in fractional in‑plane coordinates by <code>fracshift</code> before stacking. Adds a <code>&quot;z&quot;</code> extra coordinate if missing. Returns the new stacked <code>Lattice</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/supercell.jl#L177-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.crop2unitcell!-Tuple{LatticeQM.Structure.Lattices.Lattice}" href="#LatticeQM.Structure.Lattices.crop2unitcell!-Tuple{LatticeQM.Structure.Lattices.Lattice}"><code>LatticeQM.Structure.Lattices.crop2unitcell!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">crop2unitcell!(lat)</code></pre><p>Remove orbitals whose fractional coordinates fall outside <code>[0,1)</code> along the primitive directions. Operates in place and returns <code>lat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/supercell.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.crop2unitcell-Tuple{AbstractMatrix, AbstractMatrix}" href="#LatticeQM.Structure.Lattices.crop2unitcell-Tuple{AbstractMatrix, AbstractMatrix}"><code>LatticeQM.Structure.Lattices.crop2unitcell</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">crop2unitcell(positions, Λ)</code></pre><p>Return the subset of <code>positions</code> (Cartesian) that lie inside the primitive unit cell spanned by <code>Λ</code> (direct basis). Returns a matrix whose columns are the kept positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/supercell.jl#L163-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.displace!-Tuple{Any, Function}" href="#LatticeQM.Structure.Lattices.displace!-Tuple{Any, Function}"><code>LatticeQM.Structure.Lattices.displace!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">displace!(lat, f::Function)</code></pre><p>Function f takes orbital i at position p<em>i and displaces it by vector v</em>i = f(p_i).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/type.jl#L334-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.displaceZ!-Tuple{Any, Function}" href="#LatticeQM.Structure.Lattices.displaceZ!-Tuple{Any, Function}"><code>LatticeQM.Structure.Lattices.displaceZ!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">displaceZ!(lat, f::Function)</code></pre><p>Function f takes orbital i at position p<em>i and displaces it in the third coodinate by z</em>i = f(p_i).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/type.jl#L351-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.fillregion-Tuple{LatticeQM.Structure.Lattices.Lattice, Function}" href="#LatticeQM.Structure.Lattices.fillregion-Tuple{LatticeQM.Structure.Lattices.Lattice, Function}"><code>LatticeQM.Structure.Lattices.fillregion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fillregion(lat::Lattice, f::Function)</code></pre><p>Takes the d-dimensional lattice and tiles the d-dimensional region defined by function f. Returns a 0-dimensional lattice (single unit cell with no periodicities).</p><p>f(p)=true if point p belongs to the region and f(p)=false otherwise</p><p>Note: f must define a finite region that includes the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/fillregion.jl#L56-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.foldBZ!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice}" href="#LatticeQM.Structure.Lattices.foldBZ!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice}"><code>LatticeQM.Structure.Lattices.foldBZ!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">foldBZ!(points, lat::Lattice; shift=0.0)</code></pre><p>Fold k‑points (columns of <code>points</code>) into the first Brillouin zone of lattice <code>lat</code>. K‑points are assumed to be in fractional (reciprocal‑basis) coordinates. An optional <code>shift</code> vector can be subtracted before folding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/foldcell.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.foldPC!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice}" href="#LatticeQM.Structure.Lattices.foldPC!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice}"><code>LatticeQM.Structure.Lattices.foldPC!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">foldPC!(points, lat::Lattice; shift=0.0)</code></pre><p>Fold lattice coordinates (columns of <code>points</code>) into the first primitive unit cell of <code>lat</code>. Coordinates must be fractional in the direct‑lattice basis. An optional <code>shift</code> vector can be subtracted before folding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/foldcell.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.foldPC!-Tuple{LatticeQM.Structure.Lattices.Lattice}" href="#LatticeQM.Structure.Lattices.foldPC!-Tuple{LatticeQM.Structure.Lattices.Lattice}"><code>LatticeQM.Structure.Lattices.foldPC!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">foldPC!(lat::Lattice; shift=0.0)</code></pre><p>In‑place variant that folds <code>lat.spacecoordinates</code> into the first primitive unit cell of <code>lat</code>. Coordinates are interpreted as fractional. Returns the folded coordinate submatrix view for convenience.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/foldcell.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.foldcell!-Tuple{AbstractMatrix{Float64}, Matrix{Float64}}" href="#LatticeQM.Structure.Lattices.foldcell!-Tuple{AbstractMatrix{Float64}, Matrix{Float64}}"><code>LatticeQM.Structure.Lattices.foldcell!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">foldcell!(points::AbstractMatrix{Float64}, basis::Matrix{Float64})</code></pre><p>Fold columns of <code>points</code> into the first primitive unit cell defined by the column vectors of <code>basis</code> (direct-lattice basis). Internally constructs neighbor-cell vectors via <code>getneighborcells</code> and calls <code>foldcell_fromneighbors!</code> with the metric <code>basis&#39; * basis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/foldcell.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.foldcell_fromneighbors!-Tuple{AbstractMatrix{Float64}, Matrix{Float64}}" href="#LatticeQM.Structure.Lattices.foldcell_fromneighbors!-Tuple{AbstractMatrix{Float64}, Matrix{Float64}}"><code>LatticeQM.Structure.Lattices.foldcell_fromneighbors!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">foldcell_fromneighbors!(points, gvectors[, M])</code></pre><p>Fold columns of <code>points</code> into the first Wigner–Seitz cell using a list of neighbor-cell vectors <code>gvectors</code> (both in fractional coordinates). The optional metric <code>M = B&#39;B</code> can be supplied to define distances in a non-orthogonal basis, where <code>B = [G1 G2 …]</code> collects the reciprocal lattice vectors as columns.</p><p>Arguments</p><ul><li><code>points::AbstractMatrix{Float64}</code>: columns are coordinates to be folded (fractional units, i.e. in the basis of the lattice vectors).</li><li><code>gvectors::Matrix{Float64}</code>: columns are the neighbor-cell shift vectors that span the Wigner–Seitz region (fractional units).</li><li><code>M::AbstractMatrix</code> (optional): metric used to compute distances; defaults to the identity (orthonormal basis).</li></ul><p>Returns the same <code>points</code> matrix with all columns folded in place. This is the low‑level implementation used by higher‑level <code>foldcell!</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/foldcell.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.getB" href="#LatticeQM.Structure.Lattices.getB"><code>LatticeQM.Structure.Lattices.getB</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the dual lattice of lat.A. Here we use the general formula <span>$B = A * (A^T * A)^-1$</span>. That works also  when the d-dim lattice is embedded in D-dim space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/type.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.getneighborBZ-Tuple{Any, Vararg{Any}}" href="#LatticeQM.Structure.Lattices.getneighborBZ-Tuple{Any, Vararg{Any}}"><code>LatticeQM.Structure.Lattices.getneighborBZ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getneighborBZ(lat, k=1; halfspace=true, innerpoints=false, excludeorigin=true)</code></pre><p>This is the analogue of method <code>getneighborcells()</code>, except that it looks for  nearest neighbor cells in reciprocal space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/neighbors.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.getneighborcells" href="#LatticeQM.Structure.Lattices.getneighborcells"><code>LatticeQM.Structure.Lattices.getneighborcells</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getneighborcells(A, k=1; halfspace=true, innerpoints=false, excludeorigin=true)</code></pre><p>A naive implementation to find a list of <code>k</code>-th-nearest neighboring unit cells given lattice vectors <code>A[:,i]</code>. If <code>halfspace=true</code>, the list only contain <code>[I,J]</code> without its partner <code>[-I,-J]</code>. If <code>innerpoints=true</code>, returns all neighboring cells up to and including the <code>k</code>-th ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/neighbors.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.getneighborcells-Tuple{Any, Vararg{Any}}" href="#LatticeQM.Structure.Lattices.getneighborcells-Tuple{Any, Vararg{Any}}"><code>LatticeQM.Structure.Lattices.getneighborcells</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getneighborcells(lat, k=1; halfspace=true, innerpoints=false, excludeorigin=true)</code></pre><p>A naive implementation to find a list of <code>k</code>-th-nearest neighboring unit cells. If <code>halfspace=true</code>, the list only contain <code>[I,J]</code> without its partner <code>[-I,-J]</code>. If <code>innerpoints=true</code>, returns all neighboring cells up to and including the <code>k</code>-th ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/neighbors.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.repeat" href="#LatticeQM.Structure.Lattices.repeat"><code>LatticeQM.Structure.Lattices.repeat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">repeat(spacecoordinates[, Λ], repeat=[0:0, 0:0])</code></pre><p>Tile a set of point coordinates by integer translations of the lattice. Returns the concatenated coordinate matrix.</p><p>Arguments</p><ul><li><code>spacecoordinates::AbstractMatrix</code>: columns are point positions in Cartesian space.</li><li><code>Λ::AbstractMatrix</code> (optional): direct lattice basis (defaults to 2D identity).</li><li><code>repeat::Vector{&lt;:AbstractRange}</code>: ranges along a1 and a2, e.g. <code>[0:1, 0:1]</code> for 2×2.</li></ul><p>Example</p><pre><code class="language-julia hljs">coords2x2 = repeat(coords, A, [0:1, 0:1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/supercell.jl#L94-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.sortposition!" href="#LatticeQM.Structure.Lattices.sortposition!"><code>LatticeQM.Structure.Lattices.sortposition!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sortposition!(lat, name::String[, sortfunc])</code></pre><p>Sort orbitals by an extra coordinate <code>name</code> (e.g. <code>&quot;z&quot;</code>, <code>&quot;sublattice&quot;</code>). Useful for layered plots so that layers appear in front/back order. Returns the permutation applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/supercell.jl#L118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.sortposition!" href="#LatticeQM.Structure.Lattices.sortposition!"><code>LatticeQM.Structure.Lattices.sortposition!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sortposition!(lat, index::Int[, sortfunc])</code></pre><p>Index‑based variant of <code>sortposition!</code>, using the <code>index</code>‑th extra coordinate. Returns the permutation applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/supercell.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.supercellpoints-Tuple{Matrix{Int64}}" href="#LatticeQM.Structure.Lattices.supercellpoints-Tuple{Matrix{Int64}}"><code>LatticeQM.Structure.Lattices.supercellpoints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supercellpoints(M::AbstractMatrix{Int}; offset::Float64=sqrt(eps()))</code></pre><p>Given an integer lattice Z^D and an integer matrix <code>M</code> describing a (possibly non‑orthogonal) superlattice, return the integer points inside one supercell of the new lattice. The number of columns equals <code>abs(det(M))</code>.</p><p>The small <code>offset</code> avoids boundary ambiguities for points lying exactly on cell faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/supercell.jl#L216-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.superlattice-Tuple{LatticeQM.Structure.Lattices.Lattice, Matrix{Int64}, Matrix{Int64}}" href="#LatticeQM.Structure.Lattices.superlattice-Tuple{LatticeQM.Structure.Lattices.Lattice, Matrix{Int64}, Matrix{Int64}}"><code>LatticeQM.Structure.Lattices.superlattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">superlattice(lat::Lattice, S::Matrix{Int}, supercellints::Matrix{Int}; kwargs...)</code></pre><p>Low‑level constructor where the integer coordinates inside one supercell are pre‑computed and provided as <code>supercellints</code> (columns). Not intended for general users.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/supercell.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices.superlattice-Tuple{LatticeQM.Structure.Lattices.Lattice, Matrix{Int64}}" href="#LatticeQM.Structure.Lattices.superlattice-Tuple{LatticeQM.Structure.Lattices.Lattice, Matrix{Int64}}"><code>LatticeQM.Structure.Lattices.superlattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">superlattice(lat::Lattice, superperiods; kwargs...)</code></pre><p>Construct a superlattice from <code>lat</code>.</p><ul><li><code>superperiods</code>: either a vector of integers (scales each direct basis vector) or an integer matrix <code>S</code> whose columns define the linear transformation of the primitive basis, i.e. the new basis is <code>A * S</code>.</li></ul><p>Copies atoms into the new supercell and returns a new <code>Lattice</code> with updated coordinates and <code>specialpoints</code> preserved. Extra coordinates (e.g. sublattice, layer, z) are replicated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices/supercell.jl#L7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.graphene-Tuple{}" href="#LatticeQM.Structure.Geometries.graphene-Tuple{}"><code>LatticeQM.Structure.Geometries.graphene</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">graphene()</code></pre><p>Convenience alias for <code>honeycomb(1.42)</code> using a typical C–C bond length in Ångström units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.honeycomb" href="#LatticeQM.Structure.Geometries.honeycomb"><code>LatticeQM.Structure.Geometries.honeycomb</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">honeycomb(a=1.0)</code></pre><p>Two‑site honeycomb (graphene) lattice with lattice constant <code>a</code> (distance between nearest neighbors equals <code>a</code>). Adds a <code>&quot;sublattice&quot;</code> extra coordinate with values 0 (A) and 1 (B).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.honeycomb_AA" href="#LatticeQM.Structure.Geometries.honeycomb_AA"><code>LatticeQM.Structure.Geometries.honeycomb_AA</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">honeycomb_AA(a=1.0, z=3.0)</code></pre><p>AA‑stacked honeycomb bilayer with interlayer distance <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.honeycomb_AB" href="#LatticeQM.Structure.Geometries.honeycomb_AB"><code>LatticeQM.Structure.Geometries.honeycomb_AB</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">honeycomb_AB(a=1.0, z=3.0)</code></pre><p>AB (Bernal) stacking for a honeycomb bilayer with interlayer distance <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.honeycomb_ABC" href="#LatticeQM.Structure.Geometries.honeycomb_ABC"><code>LatticeQM.Structure.Geometries.honeycomb_ABC</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">honeycomb_ABC(a=1.0, z=3.0)</code></pre><p>ABC (rhombohedral) stacked tri‑layer honeycomb. Adds <code>&quot;sublattice&quot;</code> and <code>&quot;layer&quot;</code> extra coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.honeycomb_BA" href="#LatticeQM.Structure.Geometries.honeycomb_BA"><code>LatticeQM.Structure.Geometries.honeycomb_BA</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">honeycomb_BA(a=1.0, z=3.0)</code></pre><p>BA stacking variant for a honeycomb bilayer with interlayer distance <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.honeycomb_bilayer" href="#LatticeQM.Structure.Geometries.honeycomb_bilayer"><code>LatticeQM.Structure.Geometries.honeycomb_bilayer</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">honeycomb_bilayer(a=1.0, z=3.0; δ=[0.0, 0.0])</code></pre><p>Bernal‑stacked honeycomb bilayer (AB) with interlayer distance <code>z</code>. Optional in‑plane shift <code>δ</code> (fractional coordinates) moves the top layer prior to stacking. Extra coordinate <code>&quot;sublattice&quot;</code> is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.honeycomb_twisted" href="#LatticeQM.Structure.Geometries.honeycomb_twisted"><code>LatticeQM.Structure.Geometries.honeycomb_twisted</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">honeycomb_twisted(N, a=1.0, z=3.0; fold=true)</code></pre><p>Commensurate twisted bilayer graphene (TBG) with twist index <code>N</code>. If <code>fold=true</code> the structure is wrapped to the primitive cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.honeycomb_twisted_ABAB" href="#LatticeQM.Structure.Geometries.honeycomb_twisted_ABAB"><code>LatticeQM.Structure.Geometries.honeycomb_twisted_ABAB</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">honeycomb_twisted_ABAB(N, a=1.0, z=3.0; fold=true)</code></pre><p>Four‑layer twisted stack with ABAB stacking within layers prior to twisting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.honeycomb_twisted_ABBA" href="#LatticeQM.Structure.Geometries.honeycomb_twisted_ABBA"><code>LatticeQM.Structure.Geometries.honeycomb_twisted_ABBA</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">honeycomb_twisted_ABBA(N, a=1.0, z=3.0; fold=true)</code></pre><p>Four‑layer twisted stack with ABBA stacking within layers prior to twisting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.smoothdisplaceZ!" href="#LatticeQM.Structure.Geometries.smoothdisplaceZ!"><code>LatticeQM.Structure.Geometries.smoothdisplaceZ!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smoothdisplaceZ!(lat, δz_even=0.055, δz_odd=0.0; sharp=1)</code></pre><p>Apply a smooth out‑of‑plane displacement pattern to a hexagonal bilayer <code>lat</code> parameterized by even/odd amplitudes. The optional <code>sharp</code> parameter controls the smoothness (higher values approach a sign‑like modulation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L257-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.square" href="#LatticeQM.Structure.Geometries.square"><code>LatticeQM.Structure.Geometries.square</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">square(a=1.0)</code></pre><p>Square Bravais lattice with lattice constant <code>a</code>. Returns a <code>Lattice</code> with one orbital per cell and standard special k‑points (Γ, X, Y, M).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.triangular" href="#LatticeQM.Structure.Geometries.triangular"><code>LatticeQM.Structure.Geometries.triangular</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangular(a=1.0)</code></pre><p>Triangular Bravais lattice with lattice constant <code>a</code>. Returns a <code>Lattice</code> with one orbital per cell and triangular‑lattice special points (Γ, K, M, …).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.triangular_supercell" href="#LatticeQM.Structure.Geometries.triangular_supercell"><code>LatticeQM.Structure.Geometries.triangular_supercell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangular_supercell(a=1.0)</code></pre><p>A 3‑site triangular supercell useful for toy models (e.g. Kekulé). Provides a <code>&quot;sublattice&quot;</code> extra label with values 1,2,3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries.triangular_twisted" href="#LatticeQM.Structure.Geometries.triangular_twisted"><code>LatticeQM.Structure.Geometries.triangular_twisted</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangular_twisted(N, a=1.0, z=3.0; fold=true)</code></pre><p>Commensurate twisted bilayer built from triangular lattices using twist index <code>N</code> (moiré periodicity). If <code>fold=true</code>, folds positions back to the primitive cell. Sets a compact set of special k‑points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries/2d.jl#L180-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.LatticeQM" href="#LatticeQM.LatticeQM"><code>LatticeQM.LatticeQM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LatticeQM</code></pre><p>Library for tight-binding models defined on (periodic) lattices, providing  convenient functions to build the operators and to obtain bands, expectation values, topological indices, linear response coefficients and mean-field solutions.</p><p><strong>Submodules</strong></p><ul><li>Structure</li><li>TightBinding </li><li>Spectrum</li><li>Operators</li><li>LinearResponse</li><li>Meanfield</li></ul><p>Any of these modules can be further explored, e.g., with <code>?TightBinding</code></p><p><strong>Usage examples</strong></p><p>See folder <code>examples</code> of the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/LatticeQM.jl#L2-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure" href="#LatticeQM.Structure"><code>LatticeQM.Structure</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Structure</code></pre><p>Provides the struct <code>Lattices.Lattice</code> to define and manipulate lattices,  and <code>Paths.DiscretePath</code> to deal with discretized paths.</p><p>Check out the submodules:</p><ul><li>Lattices</li><li>Paths</li><li>Geometries</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Structure.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Lattices" href="#LatticeQM.Structure.Lattices"><code>LatticeQM.Structure.Lattices</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lattices</code></pre><p>Provides the type <code>Lattice</code> and methods that act on this struct, see <code>?Structure.Lattices.Lattice</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Lattices.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Structure.Geometries" href="#LatticeQM.Structure.Geometries"><code>LatticeQM.Structure.Geometries</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Geometries</code></pre><p>Provides predefined lattice objects (such as two-dimensional honeycomb lattice).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import Structure.Geometries

lat = Geometries.honeycomb_twisted(11)
plot(lat, 3; supercell=[0:1,0:1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Structure/Geometries.jl#L4-L16">source</a></section></article><h2 id="TightBinding"><a class="docs-heading-anchor" href="#TightBinding">TightBinding</a><a id="TightBinding-1"></a><a class="docs-heading-anchor-permalink" href="#TightBinding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.TightBinding.directsum-Tuple{Hops, Hops}" href="#LatticeQM.TightBinding.directsum-Tuple{Hops, Hops}"><code>LatticeQM.TightBinding.directsum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Naive implementation of combining the linear spaces of two hopping models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/TightBinding/types.jl#L204-L206">source</a></section></article><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.addhaldane!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Number}" href="#LatticeQM.Operators.addhaldane!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Number}"><code>LatticeQM.Operators.addhaldane!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>addhaldane!(hops, lat, t2; ϕ=π/2, spinhalf=false, cellrange=1, mode=:none, zmode=:none)</p><p>This method is a somewhat inefficient way to compute the haldane hopping matrix. The only upside to it is that it uses methods that I already implemented and that it is fairly general.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/haldane.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.addsublatticeimbalance!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Real}" href="#LatticeQM.Operators.addsublatticeimbalance!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Real}"><code>LatticeQM.Operators.addsublatticeimbalance!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addsublatticeimbalance!(hops, lat, Δ; kwargs...)</code></pre><p>Add a sublattice‑staggered chemical potential (imbalance) of magnitude <code>Δ</code> to <code>hops</code> on lattice <code>lat</code>. Positive values raise A and lower B (by convention).</p><p>No‑op for <code>Δ≈0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/graphene.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.addvalley!" href="#LatticeQM.Operators.addvalley!"><code>LatticeQM.Operators.addvalley!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addvalley!(hops, lat, fz=x-&gt;sign(x[3]+1e-3); kwargs...)</code></pre><p>Add a valley mass term to <code>hops</code> on <code>lat</code>. Customise the layer sign via <code>fz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/graphene.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.addzeeman!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Function}" href="#LatticeQM.Operators.addzeeman!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Function}"><code>LatticeQM.Operators.addzeeman!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addzeeman!(hops, lat, Mv::Function)</code></pre><p>Add a site‑dependent Zeeman coupling defined by the vector field <code>Mv(r)</code> to <code>hops</code> on lattice <code>lat</code>. The operator acts in spin‑1/2 space via <code>σ·M(r)</code> at each site. Modifies <code>hops</code> in place and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/zeeman.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.addzeeman!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Vector{Float64}}" href="#LatticeQM.Operators.addzeeman!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Vector{Float64}}"><code>LatticeQM.Operators.addzeeman!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addzeeman!(hops, lat, M::AbstractVector; format=:dense)</code></pre><p>Add a uniform Zeeman field <code>M = [Mx, My, Mz]</code> (constant across the lattice). If the norm of <code>M</code> is (numerically) zero, this is a no‑op. Returns <code>hops</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/zeeman.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.blockmatrix!-Tuple{AbstractMatrix, Vector{Int64}, Vector{Int64}, AbstractVector{&lt;:AbstractMatrix}}" href="#LatticeQM.Operators.blockmatrix!-Tuple{AbstractMatrix, Vector{Int64}, Vector{Int64}, AbstractVector{&lt;:AbstractMatrix}}"><code>LatticeQM.Operators.blockmatrix!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">blockmatrix(mat, I, J, V)
blockmatrix!(mat, I, J, V)</code></pre><p>Writes a sparse matrix from block matrices.</p><p>N (Int): Size of the resulting N-times-N square matrix I,J (Vector{Int}): Row/Column coordinates vec<em>of</em>mats (Vector{Matrix}): Vector of block matrices (must be equal sized in the current implementation)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/superlattice.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.droplatdim-Tuple{Hops, Int64}" href="#LatticeQM.Operators.droplatdim-Tuple{Hops, Int64}"><code>LatticeQM.Operators.droplatdim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reducelatdim(hops, index::Int)</code></pre><p>Drop a lattice dimension. For example, a two-dimensional lattice with lattice vectors a1, a2 can be turned into a 1D ribbon with lattice vector a1 by dropping all hoppings along a2 (index=2) or inteo a 1D with lattice vector a2 by dropping all hoppings along a1 (index=1).</p><p>Tip: Together with superlattice(hops, periods) one can control the width of the finite ribbon  before applying reducelatdim.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/superlattice.jl#L130-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.getcurrentoperators-Tuple{LatticeQM.Structure.Lattices.Lattice, AbstractMatrix}" href="#LatticeQM.Operators.getcurrentoperators-Tuple{LatticeQM.Structure.Lattices.Lattice, AbstractMatrix}"><code>LatticeQM.Operators.getcurrentoperators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Returns current operators [J_α,...] for each spatial coordinate α=1,...,D
given a Hamiltoinan of hopping elements `hops` and lattice structure `la`.

This should be the preferred way of generating a current operator for a given hopping Hamiltonian.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/current.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.getcurrentoperators-Tuple{LatticeQM.Structure.Lattices.Lattice, Function}" href="#LatticeQM.Operators.getcurrentoperators-Tuple{LatticeQM.Structure.Lattices.Lattice, Function}"><code>LatticeQM.Operators.getcurrentoperators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Returns current operators [J_α,...] for each spatial coordinate α=1,...,D
given a generating function t for the hopping elements of the respective Hamiltonian.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/current.jl#L5-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.getcurrentoperators-Tuple{LatticeQM.Structure.Lattices.Lattice, Hops}" href="#LatticeQM.Operators.getcurrentoperators-Tuple{LatticeQM.Structure.Lattices.Lattice, Hops}"><code>LatticeQM.Operators.getcurrentoperators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Returns current operators [J_α,...] for each spatial coordinate α=1,...,D
given a Hamiltoinan of hopping elements `hops` and lattice structure `la`.

This should be the preferred way of generating a current operator for a given hopping Hamiltonian.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/current.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.gethops-Tuple{LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}" href="#LatticeQM.Operators.gethops-Tuple{LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}"><code>LatticeQM.Operators.gethops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gethops(lat::Lattice, t::Function; cellrange=1, format=:auto, vectorized=false)</code></pre><p>Iterates over pairs of orbitals/atom positions (r1,r2) in lattice <code>lat</code> and evaluates the hopping elements t(r1+R,r2) for each lattice vector R.</p><p>By default, <code>vectorized=false</code>. For huge systems use <code>vectorized=true</code> and make  sure the hopping function t accepts matrices as arguments. The keyword argument <code>format</code> can be <code>:dense</code> or <code>:sparse</code>. For <code>:auto</code>, small systems  will be dense and huge problems are assumed to be sparse.</p><p>Returns the hopping elements in the format <code>Dict(R =&gt; t_R)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/gethops.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.getoperator-Tuple{LatticeQM.Structure.Lattices.Lattice, String, Vararg{Any}}" href="#LatticeQM.Operators.getoperator-Tuple{LatticeQM.Structure.Lattices.Lattice, String, Vararg{Any}}"><code>LatticeQM.Operators.getoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getoperator(lat::Lattice, name::String, args...; kwargs...)</code></pre><p>Return common projection/observable operators defined on <code>lat</code> by name.</p><p>Supported names (case-insensitive where noted):</p><ul><li>&quot;sx&quot;, &quot;sy&quot;, &quot;sz&quot; (or &quot;MX/MY/MZ&quot;, &quot;SX/SY/SZ&quot;): Spin Pauli components.</li><li>&quot;spinup&quot;, &quot;spindown&quot;: Projectors onto ↑/↓ in the local spin basis.</li><li>&quot;Sn&quot;: Spin along custom axis via <code>Sn(lat, n̂)</code> (see keyword forms).</li><li>&quot;layer&quot;: Layer projector for multilayer geometries.</li><li>&quot;sublattice&quot;: A/B sublattice projector; also &quot;sublatticeA&quot;, &quot;sublatticeB&quot;.</li><li>&quot;sublatticeAspin&quot;, &quot;sublatticeBspin&quot;: Sublattice-resolved spin projectors.</li></ul><p>For interaction kernels (e.g. &quot;Hubbard&quot;, &quot;CappedYukawa&quot;), use the dedicated constructors in <code>Operators</code>/<code>Meanfield</code> (see <code>gethubbard</code>, <code>getcappedyukawa</code>).</p><p>Returns a <code>Hops</code>-like operator suitable for <code>Spectrum.getbands</code> projectors or expectation-value routines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/getoperator.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.getzeeman-Tuple" href="#LatticeQM.Operators.getzeeman-Tuple"><code>LatticeQM.Operators.getzeeman</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getzeeman(lat, M; kwargs...)</code></pre><p>Construct a Zeeman term as a <code>Hops</code> operator. <code>M</code> can be either a constant magnetic field vector <code>[Mx, My, Mz]</code> (units absorbed in gμB) or a function <code>Mv(r)</code> returning a 3‑vector at position <code>r</code> for spatially varying fields.</p><p>Use <code>addzeeman!(...)</code> to add in place to an existing operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/zeeman.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.hofstadter-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Int64}" href="#LatticeQM.Operators.hofstadter-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Int64}"><code>LatticeQM.Operators.hofstadter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hofstadter(hops, lat, Q)</code></pre><p>Determines the energie spectrum as function of rational magnetic flux <span>$\Phi=p/q$</span>, where p, q are coprime integers with 1&lt;= q &lt;= Q and 1&lt;=p&lt;q. Returns a list of fluxes and a list of energies at each flux.</p><p>In this implementation we evaluate at the <span>$\Gamma$</span>-point of the magnetic cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L151-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.hofstadter_dos" href="#LatticeQM.Operators.hofstadter_dos"><code>LatticeQM.Operators.hofstadter_dos</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hofstadter_dos(hops, lat, q_max::Int, (f_min, f_max), N=300)</code></pre><p>See hofstadter<em>dos(hops, lat, q</em>max, frequencies).</p><p>Returns a list of fluxes, frequencies and a the dos at each flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L180-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.hofstadter_dos-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Int64, AbstractVector}" href="#LatticeQM.Operators.hofstadter_dos-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Int64, AbstractVector}"><code>LatticeQM.Operators.hofstadter_dos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hofstadter_dos(hops, lat, q_max::Int, frequencies::AbstractVector; klin=100, Γ=0.05)</code></pre><p>Determines the energie spectrum as function of rational magnetic flux <span>$\Phi=p/q$</span>, where p, q are coprime integers with 1&lt;= q &lt;= q<em>max and 1&lt;=p&lt;q. Note that q</em>max determines the size of the largest magnetic supercell.</p><p>The density of states (DOS) at each flux is calculated on a discrete k-grid (resolution give by <code>klin</code>). The parameter Γ determines the energy broadening when calculating DOS.</p><p>Returns a list of fluxes and a the dos at given frequencies at each flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L193-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.peierls!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, AbstractVector}" href="#LatticeQM.Operators.peierls!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, AbstractVector}"><code>LatticeQM.Operators.peierls!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peierls!(hops, lat, B)</code></pre><p>Add Peierls phases to operator <code>hops</code> on lattice geometry <code>lat</code> for the uniform magnetic field <code>B=(B1,B2,B3)</code>. Uses Coulomb gauge, see uniformfieldphase(...).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.peierls!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Function}" href="#LatticeQM.Operators.peierls!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Function}"><code>LatticeQM.Operators.peierls!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peierls!(hops, lat, phase)</code></pre><p>This method implements Peierl&#39;s substitution on a tight-binding model by adding the appropriate phases to each hopping amplitude in the Hamiltonian given by <code>hops</code>.</p><p>The phase function <code>phase</code> must be a function with the signature     phase(r1::AbstractVector, r2::AbstractVector)</p><p>Note:</p><ul><li>this should be the last step when constructing a tight-binding  Hamiltonian</li><li>You need to make sure that the phases that you add do not break translational symmetries. This is not a trivial matter and may lead to unexpected/undetected mistakes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.peierlsinplane!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, AbstractVector}" href="#LatticeQM.Operators.peierlsinplane!-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, AbstractVector}"><code>LatticeQM.Operators.peierlsinplane!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peierls!(hops, lat, B)</code></pre><p>Add Peierls phases to operator <code>hops</code> on lattice geometry <code>lat</code> for the uniform in-plane magnetic field <code>B=(B1,B2)</code>. Uses in-plane gauge, see uniformfieldphase_inplane(...).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.peierlsoutplane-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Int64, Int64}" href="#LatticeQM.Operators.peierlsoutplane-Tuple{Any, LatticeQM.Structure.Lattices.Lattice, Int64, Int64}"><code>LatticeQM.Operators.peierlsoutplane</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peierlsoutplane(hops, lat, p, q)</code></pre><p>Add uniform out-of-plane magnetic field B=(0,0,B3) to operator <code>hops</code> on lattice geometry <code>lat</code>, such that the flux per unit cell is Φ=p/q.</p><p>This method automatically constructs and returns the correct superoperartor and magnetic supercell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.setfilling!-Tuple{Any, Any, Any}" href="#LatticeQM.Operators.setfilling!-Tuple{Any, Any, Any}"><code>LatticeQM.Operators.setfilling!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setfilling!(H, kgrid::Structure.Mesh, filling; kwargs...)</code></pre><p>Variant that accepts an explicit k-grid <code>kgrid</code> (e.g., from <code>regulargrid</code>). Computes μ on that grid and shifts <code>H</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/chemicalpotential.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.setfilling!-Tuple{Any, Any}" href="#LatticeQM.Operators.setfilling!-Tuple{Any, Any}"><code>LatticeQM.Operators.setfilling!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setfilling!(H, filling; nk=100, kwargs...)</code></pre><p>Shift the chemical potential of Hamiltonian-like object <code>H</code> so that the resulting electronic filling matches <code>filling</code> (0–1 per spin). Internally uses <code>Spectrum.chemicalpotential</code> on a regular <code>nk × nk</code> grid and then applies <code>addchemicalpotential!(H, -μ)</code>.</p><p>Keywords are forwarded to the underlying solver (e.g., temperature <code>T</code>, diagonalization format).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/chemicalpotential.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.superlattice-Tuple{Hops, Vector{Int64}, Vararg{Any}}" href="#LatticeQM.Operators.superlattice-Tuple{Hops, Vector{Int64}, Vararg{Any}}"><code>LatticeQM.Operators.superlattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">superlattice(hops, periods)</code></pre><p>Turn a given hopping model into a superlattice model by copying cells and hoppings. This method can be useful as preparation before adding modulations that change the periodicity of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/superlattice.jl#L57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.uniformfieldphase-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector)" href="#LatticeQM.Operators.uniformfieldphase-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector)"><code>LatticeQM.Operators.uniformfieldphase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniformfieldphase(r1,r2; B)</code></pre><p>The proper relative phase between lattice positions r1 and r2 in presence of magnetic field B=(B<em>1,B</em>2,...). Calculated in Coulomb gauge!</p><p>The magnetic field should be in units of flux quanta <span>$\phi_0=h/e$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L223-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.uniformfieldphase_inplane-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector)" href="#LatticeQM.Operators.uniformfieldphase_inplane-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector)"><code>LatticeQM.Operators.uniformfieldphase_inplane</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniformfieldphase_inplane(r1,r2; B)</code></pre><p>The proper relative phase between lattice positions r1 and r2 in presence of magnetic field B=(B<em>1,B</em>2,0). </p><p>Here we use the gauge A = (B2 z, - B1 z, 0)</p><p>The magnetic field should be in units of flux quanta <span>$\phi_0=h/e$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L243-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.uniformfieldphase_outplane-Tuple{LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}" href="#LatticeQM.Operators.uniformfieldphase_outplane-Tuple{LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}"><code>LatticeQM.Operators.uniformfieldphase_outplane</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniformfieldphase_outplane(lat, Φ)</code></pre><p>Passes the lattice vectors a1 and a2 to uniformfieldphase_outplane(a1,a2,Φ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L275-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.uniformfieldphase_outplane-Union{Tuple{T}, Tuple{T, T, Number}} where T&lt;:(AbstractVector)" href="#LatticeQM.Operators.uniformfieldphase_outplane-Union{Tuple{T}, Tuple{T, T, Number}} where T&lt;:(AbstractVector)"><code>LatticeQM.Operators.uniformfieldphase_outplane</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniformfieldphase_outplane(a1,a2)</code></pre><p>This returns the phase function that respects translational symmetry along <span>$a_1$</span> but not along <span>$a_2$</span>. For rational flux Φ=p/q, this gauge is periodic in a2&#39;=q*a2.</p><p>The magnetic field should be in units of flux quanta <span>$\phi_0=h/e$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/peierls.jl#L287-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.valley-Tuple{Any, Vararg{Any}}" href="#LatticeQM.Operators.valley-Tuple{Any, Vararg{Any}}"><code>LatticeQM.Operators.valley</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">valley(lat; spinhalf=false, kwargs...)</code></pre><p>Construct a valley operator on <code>lat</code>. If <code>spinhalf=true</code>, attach spin structure to match spinful Hamiltonians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/graphene.jl#L87-L92">source</a></section></article><h2 id="Spectrum"><a class="docs-heading-anchor" href="#Spectrum">Spectrum</a><a id="Spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#Spectrum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.BandData" href="#LatticeQM.Spectrum.BandData"><code>LatticeQM.Spectrum.BandData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BandData</code></pre><p>Struct to store BandData obtained from method <code>getbands(...)</code>. The fields <code>BandData.bands</code> is a matrix of eigenvalues at each point along a path, the field <code>BandData.obs</code> is a matrix of expectation values and <code>BandData.path</code> is a DiscretePath object (contains discrete points and point labels).</p><p>Can be saved conveniently with <code>savedlm(bands; path=&quot;data&quot;)</code> and plotted with <code>plot(bands)</code>.``</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/types.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.bandmatrix-Tuple{Any, Any, Vararg{Any}}" href="#LatticeQM.Spectrum.bandmatrix-Tuple{Any, Any, Vararg{Any}}"><code>LatticeQM.Spectrum.bandmatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bandmatrix(H, ks::Matrix{Float} [, As]; kwargs...)</code></pre><p>Calculates the energies for operator <code>H(k)</code> for each column vector <code>k</code> of matrix <code>ks</code>. If operators <code>As=[A1, A2, ...]</code> are given, their expectaction values are calculated and stored for each eigenvector.</p><p>Accepts the same keywords as <code>geteigvals</code>, <code>geteigvecs</code>, <code>geteigen</code>. In particular: <code>format</code> (<code>:sparse</code> or <code>:dense</code>) and <code>num_bands::Int</code>.</p><p>Returns a matrix where each column contains the energies for each column <code>k</code> in <code>ks</code>. If <code>As</code> were given, a second matrix of the same format is returned containing expectation values.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using LatticeQM

lat = Geometries.honeycomb()
h = Operators.graphene(lat)
ks = kpath(lat; num_points=200)
valley = Operators.valleyoperator(lat)

bands, obs = bandmatrix(h, ks.points, valley)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/bands.jl#L107-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.berry" href="#LatticeQM.Spectrum.berry"><code>LatticeQM.Spectrum.berry</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">berry(H, NX::Int, NY::Int=0, bandindices::AbstractArray=[])</code></pre><p>Convenience method for <code>berry(statesgrid)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/berry.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.berry-Tuple{AbstractArray{&lt;:Complex, 4}}" href="#LatticeQM.Spectrum.berry-Tuple{AbstractArray{&lt;:Complex, 4}}"><code>LatticeQM.Spectrum.berry</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">berry(statesgrid)</code></pre><p>Goes through each plaquette <code>(i,j),(i+1,j),(i+1,j+1),(i,j+1)</code> and calculates the (non-abelian) plaquette phase. <code>statesgrid</code> is a four-dimenional array, containing the discretization information and the occupied states.</p><p>You can create a statesgrid with <code>statesgrid(H, nx, ny, bandindices)</code> or use the wrapper <code>berry(H, nx, ny, bandindices)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/berry.jl#L83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.berryalongpath-Tuple{Any, Any}" href="#LatticeQM.Spectrum.berryalongpath-Tuple{Any, Any}"><code>LatticeQM.Spectrum.berryalongpath</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">berryalongpath(H, kpoints)</code></pre><p>Calculate the abelian Berry curvature for each band along a path of discrete k points. It builds little plaquettes along the path between the kpoints[:,i] and kpoints[:,i+1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/berry.jl#L120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.fermisurfacedensity-Tuple{Any, Vararg{Any}}" href="#LatticeQM.Spectrum.fermisurfacedensity-Tuple{Any, Vararg{Any}}"><code>LatticeQM.Spectrum.fermisurfacedensity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermisurfacedensity(H, energies; broadening=:auto, lat=nothing, num_points=15, kwargs...)</code></pre><p>High‑level convenience that computes band energies on a regular k‑grid and then returns <code>(kgrid, density)</code> as produced by <code>fermisurfacedensity_fromdata</code>. If <code>lat</code> is provided, the grid is folded into the first Brillouin zone and mapped to Cartesian reciprocal space via <code>getB(lat)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/fermisurface.jl#L69-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.fermisurfacedensity_fromdata-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}" href="#LatticeQM.Spectrum.fermisurfacedensity_fromdata-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}"><code>LatticeQM.Spectrum.fermisurfacedensity_fromdata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermisurfacedensity_fromdata(bands, energies, obs; broadening=:auto)</code></pre><p>Weighted variant where <code>obs</code> provides an observable per band and k‑point of the same shape as <code>bands</code>. Each Lorentzian contribution is multiplied by the corresponding weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/fermisurface.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.fermisurfacedensity_fromdata-Tuple{AbstractMatrix, AbstractVector}" href="#LatticeQM.Spectrum.fermisurfacedensity_fromdata-Tuple{AbstractMatrix, AbstractVector}"><code>LatticeQM.Spectrum.fermisurfacedensity_fromdata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermisurfacedensity_fromdata(bands, energies; broadening=:auto)</code></pre><p>Broadened Fermi‑surface density without weights/observables. See <code>fermisurfacedensity_fromdata(bands, energy; ...)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/fermisurface.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.fermisurfacedensity_fromdata-Tuple{Any, Number, Vararg{Any}}" href="#LatticeQM.Spectrum.fermisurfacedensity_fromdata-Tuple{Any, Number, Vararg{Any}}"><code>LatticeQM.Spectrum.fermisurfacedensity_fromdata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermisurfacedensity_fromdata(bands, energy; broadening=:auto)</code></pre><p>Compute a broadened Fermi‑surface “density” from a band‑energy matrix <code>bands</code> of size <code>(nbands, Nk)</code> evaluated on a k‑grid. <code>energy</code> can be a scalar or a vector of Fermi energies. The result has size <code>(length(energies), Nk)</code> and sums contributions from all bands using a Lorentzian of width <code>broadening</code>.</p><p>If <code>broadening == :auto</code> (default), a heuristic width based on the band dispersion is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/fermisurface.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getbands-Tuple{Any, Any, Vararg{Any}}" href="#LatticeQM.Spectrum.getbands-Tuple{Any, Any, Vararg{Any}}"><code>LatticeQM.Spectrum.getbands</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getbands(H, ks::Union{DiscretePath, AbstractMatrix} [, As]; kwargs...)</code></pre><p>Calculates the bands for operator <code>H</code> along discrete path <code>ks</code> and if operators <code>As=[A1, A2, ...]</code> are given, their expectaction values are calculated and stored for each eigenvector.</p><p>Note that ks is a discrete path object as returned by <code>kpath(lat::Lattice,...)</code>.</p><p>Accepts the same keywords as <code>geteigvals</code>, <code>geteigvecs</code>, <code>geteigen</code>. In particular: <code>format</code> (<code>:sparse</code> or <code>:dense</code>) and <code>num_bands::Int</code>.</p><p>Returns a <code>BandData</code> object (with fields <code>bands</code>, <code>obs</code>, <code>path</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using LatticeQM

lat = Geometries.honeycomb()
h = Operators.graphene(lat)
ks = kpath(lat; num_points=200)
valley = Operators.valleyoperator(lat)

bands = getbands(h, ks, valley)

using Plots
plot(bands)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/bands.jl#L238-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getberry!-Tuple{LatticeQM.Spectrum.BandData, Any, Any}" href="#LatticeQM.Spectrum.getberry!-Tuple{LatticeQM.Spectrum.BandData, Any, Any}"><code>LatticeQM.Spectrum.getberry!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getberry!(bands, h, ks)</code></pre><p>Calculates and appends the data from <code>berryalongpath(h,ks)</code> to the data object <code>bands</code>. This is a convenience method that is useful when plotting band diagrams with Berry curvatures colored it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/berry.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getbroadening-Tuple{Any, Any}" href="#LatticeQM.Spectrum.getbroadening-Tuple{Any, Any}"><code>LatticeQM.Spectrum.getbroadening</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getbroadening(broadening, bands)</code></pre><p>Internal helper that resolves <code>broadening</code> to a numeric value. For <code>:auto</code>, uses the mean band standard deviation divided by √Nk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/fermisurface.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getcherns" href="#LatticeQM.Spectrum.getcherns"><code>LatticeQM.Spectrum.getcherns</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getcherns(wavefunctions::Function, NX::Int, NY::Int=0, bands::AbstractArray=[])</code></pre><p>Returns the chern numbers of wavefunctions corresponding to all bands in bands, where NX and NY denote the coarseness of discretization of k-space. For bands=[] it returns all chern numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/berry.jl#L309-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getdos" href="#LatticeQM.Spectrum.getdos"><code>LatticeQM.Spectrum.getdos</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getdos(h, emin::Float64, emax::Float64, num=500; kwargs...)</code></pre><p>Computes the density of states of operator h(k) on the entire Brillouine zone, discretized on a grid with $ k<em>{lin} \times k</em>{lin} $ points.  and for the frequencies ωs=(ωmin, ω2, ..., ωmax). The paremter <span>$\Gamma$</span> is the energy broadening.</p><p>Accepts the same kwargs as getdos(h, ωs; klin, Γ, kwargs...).</p><p>Note: the current implementation only works for a two-dimensional Brillouine zone. Might change in the future, but for now use dos(h, ks, ω; Γ) syntax if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/dos.jl#L82-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getdos-Tuple{Any, AbstractVector, Any, Vararg{Any}}" href="#LatticeQM.Spectrum.getdos-Tuple{Any, AbstractVector, Any, Vararg{Any}}"><code>LatticeQM.Spectrum.getdos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getdos(h, ks, ω; Γ, parallel=true, format=:auto)</code></pre><p>Computes the density of states of operator h(k) using the points ks=(k1,k2,...) and for the frequencies ω=(ω1, ω2, ...). The paremter <span>$\Gamma$</span> is the energy broadening.</p><p>Mode can be :distributed or :serial, format can be :auto, :sparse or :dense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/dos.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getdos-Tuple{Any, Any}" href="#LatticeQM.Spectrum.getdos-Tuple{Any, Any}"><code>LatticeQM.Spectrum.getdos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getdos(h, ωs; klin, Γ, kwargs...)</code></pre><p>Computes the density of states of operator h(k) on the entire Brillouine zone, discretized on a grid with $ k<em>{lin} \times k</em>{lin} $ points.  and for the frequencies ωs=(ω1, ω2, ...). The paremter <span>$\Gamma$</span> is the energy broadening.</p><p>Accepts the same kwargs as dos(h, ks, ω).</p><p>Note: the current implementation only works for a two-dimensional Brillouine zone. Might change in the future, but for now use dos(h, ks, ω; Γ) syntax if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/dos.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getwindnum" href="#LatticeQM.Spectrum.getwindnum"><code>LatticeQM.Spectrum.getwindnum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getwindnum(wavefunctions::Function, NX::Int, NY::Int=0, bandnr::Integer=1)</code></pre><p>Returns the winding number (according to Rudner et al. 2013) of the band which is on position bandnr in the spectrum. NX and NY denote the coarsness of the discretization in k-space and wavefunctions is a function returning the wavefunctions of the problem. (NB: The winding number of a band is the sum of the chern numbers of all the bands below it including its own chern number. For undriven systems or systems which are driven but &quot;normal&quot; it is equal to the chern number of said band. It only makes sense when looking at Floquet bands ie quasi-energies.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/berry.jl#L323-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.plaquettephase-Union{Tuple{T}, Tuple{N}, NTuple{4, T}} where {N, T&lt;:(AbstractArray{&lt;:Complex, N})}" href="#LatticeQM.Spectrum.plaquettephase-Union{Tuple{T}, Tuple{N}, NTuple{4, T}} where {N, T&lt;:(AbstractArray{&lt;:Complex, N})}"><code>LatticeQM.Spectrum.plaquettephase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plaquettephase(S00, S10, S01, S11)</code></pre><p>Calculates the phase the (non-abelian) phase winding around a plaquette.</p><p>This method is not meant to be called directly, it is used by <code>berry(statesgrid)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/berry.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.statesgrid" href="#LatticeQM.Spectrum.statesgrid"><code>LatticeQM.Spectrum.statesgrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">statesgrid(H, NX::Int, NY::Int=0, bandindices::AbstractArray=[])</code></pre><p>Evaluates the eigenvectors on a discretized grid (2D Hamiltonian only!) and stores the result (preserving the grid information). This method is useful when plaquette phases need to be calculated.</p><p>Note thate <code>statesgrid[i,j,:,k]</code> is the <code>k</code>-th eigenvector at gridpoint <code>i,j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/berry.jl#L7-L14">source</a></section></article><h2 id="LinearResponse"><a class="docs-heading-anchor" href="#LinearResponse">LinearResponse</a><a id="LinearResponse-1"></a><a class="docs-heading-anchor-permalink" href="#LinearResponse" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.LinearResponse.opticalconductivity-Tuple{AbstractVector, Any, Any, Any, AbstractMatrix}" href="#LatticeQM.LinearResponse.opticalconductivity-Tuple{AbstractVector, Any, Any, Any, AbstractMatrix}"><code>LatticeQM.LinearResponse.opticalconductivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opticalconductivity(frequencies, H, J1, J2, ks; μ=0.0, Γ=0.025, T=0.1, ...)</code></pre><p>Evaluate the Kubo formula for the optical conductivity tensor at the set of <code>frequencies</code> and k‑points <code>ks</code> (columns). <code>H</code>, <code>J1</code>, and <code>J2</code> are callable with a k‑vector and return the Hamiltonian and current operators, respectively.</p><p>Returns a complex vector <code>σ(ω)</code> normalized by the number of k‑points. <code>μ</code> is the chemical potential, <code>Γ</code> the phenomenological broadening and <code>T</code> the temperature (all in the same energy units as <code>H</code>). Additional keyword arguments are forwarded to the eigenvalue solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/LinearResponse/opticalconductivity.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.LinearResponse.opticalconductivity-Tuple{AbstractVector, Any, Any, Any}" href="#LatticeQM.LinearResponse.opticalconductivity-Tuple{AbstractVector, Any, Any, Any}"><code>LatticeQM.LinearResponse.opticalconductivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opticalconductivity(frequencies, H, J1, J2; klin, kwargs...)</code></pre><p>Compute σ(ω) on a regular <code>klin × klin</code> k‑grid using currents <code>J1, J2</code>. Convenience front‑end to the explicit‑grid method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/LinearResponse/opticalconductivity.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.LinearResponse.opticalconductivity-Tuple{AbstractVector, Int64, Int64, Any, LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}" href="#LatticeQM.LinearResponse.opticalconductivity-Tuple{AbstractVector, Int64, Int64, Any, LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}"><code>LatticeQM.LinearResponse.opticalconductivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opticalconductivity(frequencies, i, j, H, lat; kwargs...)</code></pre><p>Compute σ_ij(ω) for Hamiltonian <code>H(k)</code> using the Cartesian components <code>i, j</code> of the current operator defined on <code>lat</code>. Internally obtains <code>J = getcurrentoperators(lat, H)</code> and forwards to the low‑level routine.</p><p>Common keywords: <code>μ</code> (chemical potential), <code>Γ</code> (broadening), <code>T</code> (temperature), plus diagonalization options forwarded to the eigen solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/LinearResponse/opticalconductivity.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.LinearResponse.opticalconductivityXX-Tuple{AbstractVector, Any, LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}" href="#LatticeQM.LinearResponse.opticalconductivityXX-Tuple{AbstractVector, Any, LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}"><code>LatticeQM.LinearResponse.opticalconductivityXX</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opticalconductivityXX(frequencies, H, lat; kwargs...)</code></pre><p>Convenience wrapper computing σ_xx(ω) via the Kubo formula. Builds current operators from <code>H</code> and <code>lat</code> and evaluates at the provided <code>frequencies</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/LinearResponse/opticalconductivity.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.LinearResponse.opticalconductivityXY-Tuple{AbstractVector, Any, LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}" href="#LatticeQM.LinearResponse.opticalconductivityXY-Tuple{AbstractVector, Any, LatticeQM.Structure.Lattices.Lattice, Vararg{Any}}"><code>LatticeQM.LinearResponse.opticalconductivityXY</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opticalconductivityXY(frequencies, H, lat; kwargs...)</code></pre><p>Convenience wrapper computing σ_xy(ω). See <code>opticalconductivity(frequencies, i, j, H, lat; ...)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/LinearResponse/opticalconductivity.jl#L15-L20">source</a></section></article><h2 id="Meanfield"><a class="docs-heading-anchor" href="#Meanfield">Meanfield</a><a id="Meanfield-1"></a><a class="docs-heading-anchor-permalink" href="#Meanfield" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.HartreeFock" href="#LatticeQM.Meanfield.HartreeFock"><code>LatticeQM.Meanfield.HartreeFock</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HartreeFock(h, v, μ=0.0; hartree=true, fock=true)</code></pre><p>Mean‑field functional for density (Hartree) and exchange (Fock) channels built from a base Hamiltonian <code>h</code> and interaction kernels <code>v</code>. Calling the struct on <code>ρ</code> updates the effective mean‑field operator <code>hMF</code> and scalar energy <code>ϵMF</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/hartreefock.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.MeanfieldGenerator" href="#LatticeQM.Meanfield.MeanfieldGenerator"><code>LatticeQM.Meanfield.MeanfieldGenerator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeanfieldGenerator</code></pre><p>Abstract supertype for mean‑field functionals that map a density matrix <code>ρ</code> to an effective single‑particle Hamiltonian and scalar energy contributions. Concrete implementations include <code>HartreeFock</code> and <code>HartreeFockBDG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/hartreefock.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.fixedpoint!-Tuple{Any, Any, Any}" href="#LatticeQM.Meanfield.fixedpoint!-Tuple{Any, Any, Any}"><code>LatticeQM.Meanfield.fixedpoint!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fixedpoint!(f!, x1, x0; iterations=500, tol=1e-7, β=1.0, p_norm::Real=2, show_trace=false, clear_trace=false)</code></pre><p>Performs a simple fixed point iteration. The function f!(x1,x0) should override with x1 with x2 and x0 with x1 and can optionally return a scalar value (for example ground state energy at iteration step). </p><p>Fixedpoint iteration, tested on the square-root example f_a(x) = 1/2 * (a/x+x) which has the fixed point x0 = sqrt(a).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/fixedpoint.jl#L58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.mapspindensitymatrix-Tuple{AbstractVector}" href="#LatticeQM.Meanfield.mapspindensitymatrix-Tuple{AbstractVector}"><code>LatticeQM.Meanfield.mapspindensitymatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapspindensitymatrix(vs::AbstractVector, Is::AbstractVector{Int}, N::Int) --&gt; SparseMatrix{Complex}
mapspindensitymatrix(vs::AbstractVector, Is::AbstractVector{Int}) = mapspindensitymatrix(vs, Is, length(Is)) --&gt; SparseMatrix{Complex}
mapspindensitymatrix(vs::AbstractVector) --&gt; SparseMatrix{Complex}</code></pre><p>From a list of spin orientations vs (and optionally lattice indices Is, and optionally total number of lattice sites N), a spin density matrix for multiple lattice sites is generated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/initialguess.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.solvehartreefock-Union{Tuple{T}, Tuple{T, Any, Any, Number, Vararg{Any}}} where T" href="#LatticeQM.Meanfield.solvehartreefock-Union{Tuple{T}, Tuple{T, Any, Any, Number, Vararg{Any}}} where T"><code>LatticeQM.Meanfield.solvehartreefock</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solvehartreefock(h, v, ρ_init, filling; kwargs...)</code></pre><p>Convenience wrapper around <code>solveselfconsistent</code> that constructs a <code>HartreeFock</code> functional from base Hamiltonian <code>h</code> and interaction kernel <code>v</code>. Returns the converged mean‑field solution and metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/selfconsistent.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.solveselfconsistent!-Union{Tuple{T1}, Tuple{LatticeQM.Utils.Context.DummyContext, T1, T1, LatticeQM.Meanfield.MeanfieldGenerator, Float64, Any}} where T1" href="#LatticeQM.Meanfield.solveselfconsistent!-Union{Tuple{T1}, Tuple{LatticeQM.Utils.Context.DummyContext, T1, T1, LatticeQM.Meanfield.MeanfieldGenerator, Float64, Any}} where T1"><code>LatticeQM.Meanfield.solveselfconsistent!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveselfconsistent!(ρ0, ρ1, ℋ_op, ℋ_scalar, filling, ks; convergenceerror=false, multimode=:serial, checkpoint::String=&quot;&quot;, hotstart=true, iterations=500, tol=1e-7, T=0.0, format=:dense, verbose::Bool=false, kwargs...)
solveselfconsistent!(ρ0, ℋ_op, ℋ_scalar, filling, ks; kwargs...)
solveselfconsistent!(ρ0, ρ1, ℋ_op, ℋ_scalar, filling; klin, kwargs...)
solveselfconsistent!(ρ0, ℋ_op, ℋ_scalar, filling; klin, kwargs...)</code></pre><p>Searches a self-consistent meanfield solution for the functional ℋ: ρ → h at given filling (between 0 and 1). k space is discretized with the given points ks. returns (1) the density matrix of the meanfield (2) ground state energy of the meanfield operator (3) the chemical potential (4) convergence flag (bool) (5) error estimate</p><p>If the checkpoint keyword is set, e.g. <code>checkpoint=&quot;mf.jld&quot;</code>, the mean field will be saved into a file at each step of the iteration, allowing to interrupt and restart a long-running calculation safely. If <code>checkpoint</code> is set and the file exists, this method will assume that the file contains a valid mean-field and use it as initial guess. To avoid this behavior, specify <code>hotstart=false</code>.</p><p>parallel=true might help if diagonalization per k point is very time consuming (e.g. for twisted bilayer graphene) note that for small problems <code>parallel=true</code> may decrease performance (communication overhead)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/selfconsistent.jl#L81-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.solveselfconsistent-Tuple{Any, LatticeQM.Meanfield.MeanfieldGenerator, Number, Any}" href="#LatticeQM.Meanfield.solveselfconsistent-Tuple{Any, LatticeQM.Meanfield.MeanfieldGenerator, Number, Any}"><code>LatticeQM.Meanfield.solveselfconsistent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveselfconsistent(ρ0, mf::MeanfieldGenerator, filling, ks; kwargs...)
solveselfconsistent(ρ0, mf::MeanfieldGenerator, filling; klin, kwargs...)</code></pre><p>Non‑mutating convenience wrappers around [<code>solveselfconsistent!</code>] that copy the initial density matrix <code>ρ0</code>, iterate the mean‑field functional <code>mf</code> (e.g., <code>HartreeFock</code>), and return the converged result together with energy and state.</p><p>The <code>filling</code> sets the target electronic filling (0–1 per spin). Supply either an explicit k‑grid <code>ks</code> or a grid resolution via <code>klin</code> (uses <code>klin×klin</code>).</p><p>Common keywords: <code>iterations</code>, <code>tol</code>, <code>T</code>, <code>β</code> (mixing), <code>multimode</code> (parallel).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/selfconsistent.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.solveselfconsistent_purification!-Union{Tuple{T1}, Tuple{LatticeQM.Utils.Context.DummyContext, T1, T1, LatticeQM.Meanfield.MeanfieldGenerator, Float64, Any}} where T1" href="#LatticeQM.Meanfield.solveselfconsistent_purification!-Union{Tuple{T1}, Tuple{LatticeQM.Utils.Context.DummyContext, T1, T1, LatticeQM.Meanfield.MeanfieldGenerator, Float64, Any}} where T1"><code>LatticeQM.Meanfield.solveselfconsistent_purification!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveselfconsistent!(ρ0, ρ1, ℋ_op, ℋ_scalar, filling, ks; convergenceerror=false, multimode=:serial, checkpoint::String=&quot;&quot;, hotstart=true, iterations=500, tol=1e-7, T=0.0, format=:dense, verbose::Bool=false, kwargs...)
solveselfconsistent!(ρ0, ℋ_op, ℋ_scalar, filling, ks; kwargs...)
solveselfconsistent!(ρ0, ρ1, ℋ_op, ℋ_scalar, filling; klin, kwargs...)
solveselfconsistent!(ρ0, ℋ_op, ℋ_scalar, filling; klin, kwargs...)</code></pre><p>Searches a self-consistent meanfield solution for the functional ℋ: ρ → h at given filling (between 0 and 1). k space is discretized with the given points ks. returns (1) the density matrix of the meanfield (2) ground state energy of the meanfield operator (3) the chemical potential (4) convergence flag (bool) (5) error estimate</p><p>If the checkpoint keyword is set, e.g. <code>checkpoint=&quot;mf.jld&quot;</code>, the mean field will be saved into a file at each step of the iteration, allowing to interrupt and restart a long-running calculation safely. If <code>checkpoint</code> is set and the file exists, this method will assume that the file contains a valid mean-field and use it as initial guess. To avoid this behavior, specify <code>hotstart=false</code>.</p><p>parallel=true might help if diagonalization per k point is very time consuming (e.g. for twisted bilayer graphene) note that for small problems <code>parallel=true</code> may decrease performance (communication overhead)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/selfconsistent_purification.jl#L183-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.spindensitymatrix" href="#LatticeQM.Meanfield.spindensitymatrix"><code>LatticeQM.Meanfield.spindensitymatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spindensitymatrix(d::Vector=[1,0,0]) --&gt; Matrix{Float64}
spindensitymatrix(x::Real=1) --&gt; Matrix{Float64}
spindensitymatrix(s::Symbol) --&gt; Matrix{Float64}</code></pre><p>Returns a spin-1/2 density matrix for given spin orientiation d=[dx,dy,dz]. Instead, one can also specify the configuration symbolically, in which case s should be one of <code>:up,:down,:upx,:downx,:upy,:downy</code>.</p><p>If vector has norm larger one it gets normalized, otherwise it is left unscaled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/initialguess.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.spinspiraldensitymatrix-Tuple{LatticeQM.Structure.Lattices.Lattice, Any}" href="#LatticeQM.Meanfield.spinspiraldensitymatrix-Tuple{LatticeQM.Structure.Lattices.Lattice, Any}"><code>LatticeQM.Meanfield.spinspiraldensitymatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spinspiraldensitymatrix(lat::Lattice, superperiods; n::Vector=[0,0,1], v0::Vector=[1,0,0])</code></pre><p>Create a spin spiral density matrix with periodicity given by a superlattice characterized by <code>superperiods&#39; (see Structure.superlattice for details). The rotation goes around the fixed axis</code>n=[n1,n2,n3]<code>. The vector</code>v0` specifies the spin direction in one site.</p><p>Useful to create initial states for mean field calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/initialguess.jl#L104-L111">source</a></section></article><h2 id="Superconductivity"><a class="docs-heading-anchor" href="#Superconductivity">Superconductivity</a><a id="Superconductivity-1"></a><a class="docs-heading-anchor-permalink" href="#Superconductivity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Superconductivity.BdGOperator" href="#LatticeQM.Superconductivity.BdGOperator"><code>LatticeQM.Superconductivity.BdGOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BdGOperator(h::Hops)
BdGOperator(h::Hops, Δ::Hops)</code></pre><p>Bogoliubov–de Gennes operator wrapper that lifts a normal‑state hopping object <code>h</code> to Nambu space and optionally adds a pairing block <code>Δ</code>. The resulting operator behaves like a Hamiltonian <code>H(k)</code> and can be passed to spectrum and mean‑field routines.</p><p>Related helpers:</p><ul><li><code>addpairing!(H::BdGOperator, Δ)</code> — insert/update the pairing block.</li><li><code>addelectronsector!(H::BdGOperator, h)</code> — add to the electron block.</li><li><code>getelectionview/getpairingview</code> — views into electron/pairing sectors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Superconductivity/types.jl#L5-L18">source</a></section></article><h2 id="Floquet"><a class="docs-heading-anchor" href="#Floquet">Floquet</a><a id="Floquet-1"></a><a class="docs-heading-anchor-permalink" href="#Floquet" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.periodicDrive" href="#LatticeQM.Floquet.periodicDrive"><code>LatticeQM.Floquet.periodicDrive</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodicDrive(omega::Number=1)</code></pre><p>Return an empty periodic drive with frequency omega.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/types.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.periodicDrive" href="#LatticeQM.Floquet.periodicDrive"><code>LatticeQM.Floquet.periodicDrive</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct periodicDrive</code></pre><p>Type representing a time-periodic potential applied to a lattice. Contains the fields:  </p><ul><li>omega: Frequency of the potential.  </li><li>operators: An array of operators (Matrices) representing the Fourier components of the potential.  </li><li>ns: An array of integers containing the modes which are not zero. (Should not contain 0)    This implies that operators and ns must have the same length and must be ordered such that    operators[i] corresponds to the ns[i] fourier component for all i.</li></ul><p>Example:       The following returns a drive corresponding to a periodic potentisl V(t):       V(t) = [0 1; -1 0]<em>exp(-im</em>2.5<em>t) + [0 -1; 1 0]</em>exp(3<em>im</em>2.5*t)</p><pre><code class="language-julia hljs">drive = periodicDrive(2.5, [[0 1; -1 0], [0 -1; 1 0]], [-1,3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/types.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.periodicDrive-Tuple{Number, AbstractVector{Number}, AbstractMatrix{Number}}" href="#LatticeQM.Floquet.periodicDrive-Tuple{Number, AbstractVector{Number}, AbstractMatrix{Number}}"><code>LatticeQM.Floquet.periodicDrive</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodicDrive(omega::Number, funcFourier::AbstractArray{Number, 1}, operator::AbstractMatrix{Number})</code></pre><p>Allows for initializing a periodicDrive using only one operator and Fourier components of a periodic function denoting the amplitude (over time) with which the operator is applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/types.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.addFreq!-Tuple{LatticeQM.Floquet.periodicDrive, AbstractMatrix, Integer}" href="#LatticeQM.Floquet.addFreq!-Tuple{LatticeQM.Floquet.periodicDrive, AbstractMatrix, Integer}"><code>LatticeQM.Floquet.addFreq!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addFreq!(drive::periodicDrive, operator::AbstractMatrix, n::Integer)</code></pre><p>Add a single harmonic mode to an existing periodicDrive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/types.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.addcos!-Tuple{LatticeQM.Floquet.periodicDrive, AbstractMatrix, Integer}" href="#LatticeQM.Floquet.addcos!-Tuple{LatticeQM.Floquet.periodicDrive, AbstractMatrix, Integer}"><code>LatticeQM.Floquet.addcos!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addcos!(drive::periodicDrive, operator::AbstractMatrix, n::Integer)</code></pre><p>Add the operator applied with a cosine of frequency n*omega to an existing periodicDrive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/types.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.getFloquetMatrix-Tuple{Integer, AbstractMatrix, LatticeQM.Floquet.periodicDrive}" href="#LatticeQM.Floquet.getFloquetMatrix-Tuple{Integer, AbstractMatrix, LatticeQM.Floquet.periodicDrive}"><code>LatticeQM.Floquet.getFloquetMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getFloquetMatrix(M::Integer, H0::AbstractMatrix, drive::periodicDrive; hbar::Number=1.)</code></pre><p>Build the effective Hamiltonian for several harmonic driving modes, i.e., <span>$V(t) = \sum_j V_j \exp(i*j*n_j*\omega)$</span>.</p><p>M: truncation   H0: time averaged Hamiltonian (i.e., has already absorbed the constant m=0 mode), must be matrix drive: periodicDrive object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/hamiltonian.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.getfirstFBZ-Tuple{AbstractArray, Integer}" href="#LatticeQM.Floquet.getfirstFBZ-Tuple{AbstractArray, Integer}"><code>LatticeQM.Floquet.getfirstFBZ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>function reducetoFBZ(bands::AbstractArray, M::Integer) Takes a two dimensional array denoting a list of bands which came from diagonalizing a Floquet Hamiltonian and returns the bands lying in the first Floquet Brioullin zone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/spectrum.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.keepfirstFBZ!-Tuple{LatticeQM.Spectrum.BandData, LatticeQM.Floquet.FloquetOperator}" href="#LatticeQM.Floquet.keepfirstFBZ!-Tuple{LatticeQM.Spectrum.BandData, LatticeQM.Floquet.FloquetOperator}"><code>LatticeQM.Floquet.keepfirstFBZ!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">keepfirstFBZ!(data::Spectrum.BandData, H::FloquetOperator)</code></pre><p>Throw away all band data except for the first Floquet Brillouin zone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/spectrum.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.transform-Tuple{Vector{ComplexF64}, Integer, Integer, Number}" href="#LatticeQM.Floquet.transform-Tuple{Vector{ComplexF64}, Integer, Integer, Number}"><code>LatticeQM.Floquet.transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Converts an eigenvector vec obtained from solving the infinite (truncated at M) Floquet problem to an eigenvector in time space (at time t).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/spectrum.jl#L32-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Floquet.transformeigvecs-Tuple{AbstractMatrix, Integer, Number}" href="#LatticeQM.Floquet.transformeigvecs-Tuple{AbstractMatrix, Integer, Number}"><code>LatticeQM.Floquet.transformeigvecs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>transformeigvecs(U::AbstractMatrix, M::Integer, t::Number) Converts a matrix of eigenvectors U obtained from solving the infinite (truncated at M) Floquet problem to eigenvectors in time space (at time t).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Floquet/spectrum.jl#L18-L21">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><h2 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Utils.padvec-Tuple{AbstractVector, Int64}" href="#LatticeQM.Utils.padvec-Tuple{AbstractVector, Int64}"><code>LatticeQM.Utils.padvec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">padvec(v::AbstractVector, d::Int)</code></pre><p>Make sure Vector v has length d, pad with zeros if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Utils/Utils.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Utils.spinorrotation" href="#LatticeQM.Utils.spinorrotation"><code>LatticeQM.Utils.spinorrotation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spinorrotation(θ, n=[0,0,1])</code></pre><p>Returns SU(2) spinor rotation matrix U parametrized by rotation angle θ and rotation axis n=[n1,n2,n3]. U = exp(-i (θ/2) σ.n).</p><p>Note: This routine will always normalize n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Utils/paulimatrices.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Utils.@scalar2vector" href="#LatticeQM.Utils.@scalar2vector"><code>LatticeQM.Utils.@scalar2vector</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scalar2vector(f0, N=3)</code></pre><p>This is macro is a wrapper that takes as input a function f0(x::Float64) and adds a new dispatch f0(r1::Vector, r2::Vector) = f0(norm(r1-r2)) while making sure that r1 and r2 do not exceed length N.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Utils/scalar2vector.jl#L3-L8">source</a></section></article><h2 id="Common-Entrypoints"><a class="docs-heading-anchor" href="#Common-Entrypoints">Common Entrypoints</a><a id="Common-Entrypoints-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Entrypoints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getbands" href="#LatticeQM.Spectrum.getbands"><code>LatticeQM.Spectrum.getbands</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getbands(H, ks::Union{DiscretePath, AbstractMatrix} [, As]; kwargs...)</code></pre><p>Calculates the bands for operator <code>H</code> along discrete path <code>ks</code> and if operators <code>As=[A1, A2, ...]</code> are given, their expectaction values are calculated and stored for each eigenvector.</p><p>Note that ks is a discrete path object as returned by <code>kpath(lat::Lattice,...)</code>.</p><p>Accepts the same keywords as <code>geteigvals</code>, <code>geteigvecs</code>, <code>geteigen</code>. In particular: <code>format</code> (<code>:sparse</code> or <code>:dense</code>) and <code>num_bands::Int</code>.</p><p>Returns a <code>BandData</code> object (with fields <code>bands</code>, <code>obs</code>, <code>path</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using LatticeQM

lat = Geometries.honeycomb()
h = Operators.graphene(lat)
ks = kpath(lat; num_points=200)
valley = Operators.valleyoperator(lat)

bands = getbands(h, ks, valley)

using Plots
plot(bands)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/bands.jl#L238-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Spectrum.getdos" href="#LatticeQM.Spectrum.getdos"><code>LatticeQM.Spectrum.getdos</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getdos(h, emin::Float64, emax::Float64, num=500; kwargs...)</code></pre><p>Computes the density of states of operator h(k) on the entire Brillouine zone, discretized on a grid with $ k<em>{lin} \times k</em>{lin} $ points.  and for the frequencies ωs=(ωmin, ω2, ..., ωmax). The paremter <span>$\Gamma$</span> is the energy broadening.</p><p>Accepts the same kwargs as getdos(h, ωs; klin, Γ, kwargs...).</p><p>Note: the current implementation only works for a two-dimensional Brillouine zone. Might change in the future, but for now use dos(h, ks, ω; Γ) syntax if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/dos.jl#L82-L93">source</a></section><section><div><pre><code class="language-julia hljs">getdos(h, ωs; klin, Γ, kwargs...)</code></pre><p>Computes the density of states of operator h(k) on the entire Brillouine zone, discretized on a grid with $ k<em>{lin} \times k</em>{lin} $ points.  and for the frequencies ωs=(ω1, ω2, ...). The paremter <span>$\Gamma$</span> is the energy broadening.</p><p>Accepts the same kwargs as dos(h, ks, ω).</p><p>Note: the current implementation only works for a two-dimensional Brillouine zone. Might change in the future, but for now use dos(h, ks, ω; Γ) syntax if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/dos.jl#L96-L107">source</a></section><section><div><pre><code class="language-julia hljs">getdos(h, ks, ω; Γ, parallel=true, format=:auto)</code></pre><p>Computes the density of states of operator h(k) using the points ks=(k1,k2,...) and for the frequencies ω=(ω1, ω2, ...). The paremter <span>$\Gamma$</span> is the energy broadening.</p><p>Mode can be :distributed or :serial, format can be :auto, :sparse or :dense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Spectrum/dos.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.LinearResponse.opticalconductivity" href="#LatticeQM.LinearResponse.opticalconductivity"><code>LatticeQM.LinearResponse.opticalconductivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opticalconductivity(frequencies, i, j, H, lat; kwargs...)</code></pre><p>Compute σ_ij(ω) for Hamiltonian <code>H(k)</code> using the Cartesian components <code>i, j</code> of the current operator defined on <code>lat</code>. Internally obtains <code>J = getcurrentoperators(lat, H)</code> and forwards to the low‑level routine.</p><p>Common keywords: <code>μ</code> (chemical potential), <code>Γ</code> (broadening), <code>T</code> (temperature), plus diagonalization options forwarded to the eigen solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/LinearResponse/opticalconductivity.jl#L27-L36">source</a></section><section><div><pre><code class="language-julia hljs">opticalconductivity(frequencies, H, J1, J2; klin, kwargs...)</code></pre><p>Compute σ(ω) on a regular <code>klin × klin</code> k‑grid using currents <code>J1, J2</code>. Convenience front‑end to the explicit‑grid method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/LinearResponse/opticalconductivity.jl#L46-L51">source</a></section><section><div><pre><code class="language-julia hljs">opticalconductivity(frequencies, H, J1, J2, ks; μ=0.0, Γ=0.025, T=0.1, ...)</code></pre><p>Evaluate the Kubo formula for the optical conductivity tensor at the set of <code>frequencies</code> and k‑points <code>ks</code> (columns). <code>H</code>, <code>J1</code>, and <code>J2</code> are callable with a k‑vector and return the Hamiltonian and current operators, respectively.</p><p>Returns a complex vector <code>σ(ω)</code> normalized by the number of k‑points. <code>μ</code> is the chemical potential, <code>Γ</code> the phenomenological broadening and <code>T</code> the temperature (all in the same energy units as <code>H</code>). Additional keyword arguments are forwarded to the eigenvalue solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/LinearResponse/opticalconductivity.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.solvehartreefock" href="#LatticeQM.Meanfield.solvehartreefock"><code>LatticeQM.Meanfield.solvehartreefock</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solvehartreefock(h, v, ρ_init, filling; kwargs...)</code></pre><p>Convenience wrapper around <code>solveselfconsistent</code> that constructs a <code>HartreeFock</code> functional from base Hamiltonian <code>h</code> and interaction kernel <code>v</code>. Returns the converged mean‑field solution and metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/selfconsistent.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Meanfield.solveselfconsistent" href="#LatticeQM.Meanfield.solveselfconsistent"><code>LatticeQM.Meanfield.solveselfconsistent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveselfconsistent(ρ0, mf::MeanfieldGenerator, filling, ks; kwargs...)
solveselfconsistent(ρ0, mf::MeanfieldGenerator, filling; klin, kwargs...)</code></pre><p>Non‑mutating convenience wrappers around [<code>solveselfconsistent!</code>] that copy the initial density matrix <code>ρ0</code>, iterate the mean‑field functional <code>mf</code> (e.g., <code>HartreeFock</code>), and return the converged result together with energy and state.</p><p>The <code>filling</code> sets the target electronic filling (0–1 per spin). Supply either an explicit k‑grid <code>ks</code> or a grid resolution via <code>klin</code> (uses <code>klin×klin</code>).</p><p>Common keywords: <code>iterations</code>, <code>tol</code>, <code>T</code>, <code>β</code> (mixing), <code>multimode</code> (parallel).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Meanfield/selfconsistent.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeQM.Operators.setfilling!" href="#LatticeQM.Operators.setfilling!"><code>LatticeQM.Operators.setfilling!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setfilling!(H, filling; nk=100, kwargs...)</code></pre><p>Shift the chemical potential of Hamiltonian-like object <code>H</code> so that the resulting electronic filling matches <code>filling</code> (0–1 per spin). Internally uses <code>Spectrum.chemicalpotential</code> on a regular <code>nk × nk</code> grid and then applies <code>addchemicalpotential!(H, -μ)</code>.</p><p>Keywords are forwarded to the underlying solver (e.g., temperature <code>T</code>, diagonalization format).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/chemicalpotential.jl#L9-L19">source</a></section><section><div><pre><code class="language-julia hljs">setfilling!(H, kgrid::Structure.Mesh, filling; kwargs...)</code></pre><p>Variant that accepts an explicit k-grid <code>kgrid</code> (e.g., from <code>regulargrid</code>). Computes μ on that grid and shifts <code>H</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skilledwolf/LatticeQM.jl/blob/107c7dd1397bcd0a8f0a84eec4873fd8cf2906f8/src/modules/Operators/chemicalpotential.jl#L29-L34">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../contributing/">« Contributor Guide</a><a class="docs-footer-nextpage" href="../publications/">Publications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Saturday 1 November 2025 16:25">Saturday 1 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
